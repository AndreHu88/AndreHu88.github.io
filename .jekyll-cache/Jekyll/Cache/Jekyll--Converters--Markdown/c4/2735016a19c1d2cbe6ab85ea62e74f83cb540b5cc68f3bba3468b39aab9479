I"Ğ2<h5 id="apmç›‘æ§å¡é¡¿å¹¶ä¸ŠæŠ¥æœ‰ä¸¤ç§æ–¹æ¡ˆ">APMç›‘æ§å¡é¡¿å¹¶ä¸ŠæŠ¥æœ‰ä¸¤ç§æ–¹æ¡ˆï¼š</h5>
<ol>
  <li>ç›‘å¬RunloopçŠ¶æ€å›è°ƒï¼Œ å­çº¿ç¨‹pingä¸»çº¿ç¨‹
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry )
        // é€šçŸ¥ Observers: RunLoop å³å°†è¿›å…¥ loop
        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    // è¿›å…¥loop
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
</code></pre></div>    </div>
  </li>
  <li>
    <p>å¼€å¯do while å¾ªç¯ä¿æ´»çº¿ç¨‹ï¼Œé€šçŸ¥Observers, Runloopè§¦å‘timerå›è°ƒï¼Œç„¶åæ‰§è¡Œè¢«åŠ å…¥çš„Block
```
  if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)
     //  é€šçŸ¥ Observers: RunLoop å³å°†è§¦å‘ Timer å›è°ƒ
     __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</p>

    <p>if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)
     //  é€šçŸ¥ Observers: RunLoop å³å°†è§¦å‘ Source å›è°ƒ
     __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);
 // æ‰§è¡Œè¢«åŠ å…¥çš„block
 __CFRunLoopDoBlocks(rl, rlm);</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3. runloopè§¦å‘source0çš„å›è°ƒï¼Œå¦‚æœsource1æ˜¯readyçŠ¶æ€ï¼Œä¼šè·³è½¬åˆ°handle_msgå»å¤„ç†æ¶ˆæ¯, å¦‚æœæœ‰ Source1 (åŸºäºport) å¤„äº ready çŠ¶æ€ï¼Œç›´æ¥å¤„ç†è¿™ä¸ª Source1 ç„¶åè·³è½¬å»å¤„ç†æ¶ˆæ¯

</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) {
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
    msg = (mach_msg_header_t *)msg_buffer;
    
    if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) {
        goto handle_msg;
    }
#elif DEPLOYMENT_TARGET_WINDOWS
    if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) {
        goto handle_msg;
    }
#endif
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4. å›è°ƒè§¦å‘åï¼Œé€šçŸ¥Observerè¿›å…¥ä¼‘çœ çŠ¶æ€
</code></pre></div></div>
<p>Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);
 // é€šçŸ¥ Observers: RunLoop çš„çº¿ç¨‹å³å°†è¿›å…¥ä¼‘çœ (sleep)
 if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);
     __CFRunLoopSetSleeping(rl);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5. ä¼‘çœ åï¼Œç­‰å¾…mach_portæ¶ˆæ¯ï¼Œä»¥ä¾¿å†æ¬¡å”¤é†’
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do {
    if (kCFUseCollectableAllocator) {
        // objc_clear_stack(0);
        // &lt;rdar://problem/16393959&gt;
        memset(msg_buffer, 0, sizeof(msg_buffer));
    }
    msg = (mach_msg_header_t *)msg_buffer;
    
    __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);
    
    if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) {
        // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.
        while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));
        if (rlm-&gt;_timerFired) {
            // Leave livePort as the queue port, and service timers below
            rlm-&gt;_timerFired = false;
            break;
        } else {
            if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);
        }
    } else {
        // Go ahead and leave the inner loop.
        break;
    }
} while (1);
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
6. å”¤é†’æ—¶é€šçŸ¥Observerï¼Œ Runloopçš„çº¿ç¨‹åˆšåˆšè¢«å”¤é†’äº†
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// é€šçŸ¥ Observers: RunLoop çš„çº¿ç¨‹åˆšåˆšè¢«å”¤é†’äº†
if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);
    // å¤„ç†æ¶ˆæ¯
    handle_msg:;
    __CFRunLoopSetIgnoreWakeUps(rl);  ```
</code></pre></div></div>

<ol>
  <li>Runloopå”¤é†’åï¼Œå¤„ç†å”¤é†’æ—¶æ”¶åˆ°çš„æ¶ˆæ¯</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>///å¦‚æœæ˜¯Timerå¤„ç†å›è°ƒ
///å¦‚æœæ˜¯dispatchï¼Œå¤„ç†block
///å¦‚æœæ˜¯source1ï¼Œ å¤„ç†äº‹ä»¶

 #if USE_MK_TIMER_TOO
         // å¦‚æœä¸€ä¸ª Timer åˆ°æ—¶é—´äº†ï¼Œè§¦å‘è¿™ä¸ªTimerçš„å›è°ƒ
         else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) {
             CFRUNLOOP_WAKEUP_FOR_TIMER();
             // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be 'too early' for the next timer, and no timers are handled.
             // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754
             if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
                 // Re-arm the next timer
                 __CFArmNextTimerInMode(rlm, rl);
             }
         }
 #endif
         //  å¦‚æœæœ‰dispatchåˆ°main_queueçš„blockï¼Œæ‰§è¡Œblock
         else if (livePort == dispatchPort) {
             CFRUNLOOP_WAKEUP_FOR_DISPATCH();
             __CFRunLoopModeUnlock(rlm);
             __CFRunLoopUnlock(rl);
             _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);
 #if DEPLOYMENT_TARGET_WINDOWS
             void *msg = 0;
 #endif
             __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
             _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);
             __CFRunLoopLock(rl);
             __CFRunLoopModeLock(rlm);
             sourceHandledThisLoop = true;
             didDispatchPortLastTime = true;
         }
         // å¦‚æœä¸€ä¸ª Source1 (åŸºäºport) å‘å‡ºäº‹ä»¶äº†ï¼Œå¤„ç†è¿™ä¸ªäº‹ä»¶
         else {
             CFRUNLOOP_WAKEUP_FOR_SOURCE();
             
             // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.
             voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);

             CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);
             if (rls) {
 #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
         mach_msg_header_t *reply = NULL;
         sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;
         if (NULL != reply) {
             (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
             CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);
         }
 #elif DEPLOYMENT_TARGET_WINDOWS
                 sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;
 #endif

</code></pre></div></div>
<ol>
  <li>æ ¹æ®å½“å‰runloopçŠ¶æ€åˆ¤æ–­æ˜¯å¦éœ€è¦è¿›å…¥ä¸‹ä¸€ä¸ªloop, å½“è¢«å¤–éƒ¨å¼ºåˆ¶åœæ­¢æˆ–è€…loopè¶…æ—¶ï¼Œå°±ä¸ç»§ç»­ä¸‹ä¸€ä¸ªloop,  å¦åˆ™è¿›å…¥ä¸‹ä¸€ä¸ªloop</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
    if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {
        // è¿›å…¥loopæ—¶å‚æ•°è¯´å¤„ç†å®Œäº‹ä»¶å°±è¿”å›
        retVal = kCFRunLoopRunHandledSource;
        } else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) {
            // è¶…å‡ºä¼ å…¥å‚æ•°æ ‡è®°çš„è¶…æ—¶æ—¶é—´äº†
            retVal = kCFRunLoopRunTimedOut;
    } else if (__CFRunLoopIsStopped(rl)) {
            __CFRunLoopUnsetStopped(rl);
        // è¢«å¤–éƒ¨è°ƒç”¨è€…å¼ºåˆ¶åœæ­¢äº†
        retVal = kCFRunLoopRunStopped;
    } else if (rlm-&gt;_stopped) {
        rlm-&gt;_stopped = false;
        retVal = kCFRunLoopRunStopped;
    } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {
        // source/timerä¸€ä¸ªéƒ½æ²¡æœ‰
        retVal = kCFRunLoopRunFinished;
    }

 */

/// Source1æ˜¯runloopç”¨æ¥å¤„ç†Mach portä¼ æ¥çš„ç³»ç»Ÿçš„äº‹ä»¶çš„ï¼Œ  Source0æ˜¯ç”¨æ¥å¤„ç†ç”¨æˆ·äº‹ä»¶çš„
/// æ£€æµ‹runloopï¼Œä¸€æ—¦å‘ç°åœ¨è¿›å…¥ç¡çœ å‰çš„KCFRunLoopBeforeSourcesåˆ°å”¤é†’å KCFRunLoopAfterWaitingçš„æ—¶é—´è¿‡é•¿ï¼Œè¯´æ˜Runloopå¡é¡¿äº†ï¼Œ å¼€å¯ä¸€ä¸ªå­çº¿ç¨‹ï¼Œä¸æ–­çš„å»å¾ªç¯æ£€æµ‹ï¼Œå¦‚æœåœ¨næ¬¡éƒ½è¶…è¿‡äº†é¢„å®šå¥½çš„é˜ˆå€¼ï¼Œ è®¤ä¸ºæ˜¯å¡é¡¿äº†ï¼Œ ç„¶åè¿›è¡Œdumpå½“å‰çš„å †æ ˆå¹¶ä¸ŠæŠ¥

/**
 é€šè¿‡ long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)  æ–¹æ³•åˆ¤æ–­æ˜¯å¦é˜»å¡ä¸»çº¿ç¨‹ï¼ŒReturns zero on success, or non-zero if the timeout occurred.  è¿”å›é0åˆ™ä»£è¡¨è¶…æ—¶é˜»å¡äº†ä¸»çº¿ç¨‹
 */



//MARK: å­çº¿ç¨‹pingä¸»çº¿ç¨‹ç›‘å¬çš„æ–¹å¼
///å¼€å¯ä¸€ä¸ªå­çº¿ç¨‹ï¼Œåˆ›å»ºä¸€ä¸ªåˆå§‹å€¼ä¸º0çš„ä¿¡å·é‡ï¼Œ ä¸€ä¸ªboolæ ‡å¿—ä½ï¼Œå°†è®¾ç½®ä¸ºNOçš„æ ‡å¿—ä½çš„ä»»åŠ¡æ´¾å‘åˆ°ä¸»çº¿ç¨‹ä¸­å»ï¼Œ å­çº¿ç¨‹ä¼‘çœ é˜ˆå€¼åˆ°ååˆ¤æ–­æ˜¯å¦è¢«ä¸»çº¿ç¨‹æˆåŠŸï¼Œå¦‚æœæ²¡æˆåŠŸè®¤ä¸ºæ˜¯ä¸»çº¿ç¨‹å¡é¡¿
/*
 
 while (self.isCancelled == NO) {
 
     @autoreleasepool {
         __block BOOL isMainThreadNoRespond = YES;
         
         dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
         
         dispatch_async(dispatch_get_main_queue(), ^{
             isMainThreadNoRespond = NO;
             dispatch_semaphore_signal(semaphore);
         });
         
         [NSThread sleepForTimeInterval:self.threshold];
         
         if (isMainThreadNoRespond) {
             if (self.handlerBlock) {
                 self.handlerBlock(); // å¤–éƒ¨åœ¨ block å†…éƒ¨ dump å †æ ˆï¼ˆä¸‹é¢ä¼šè®²ï¼‰ï¼Œæ•°æ®ä¸ŠæŠ¥
             }
         }
         
         dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
     }
 }

</code></pre></div></div>

<h5 id="å¯åŠ¨æ—¶é—´ç›‘æ§">å¯åŠ¨æ—¶é—´ç›‘æ§</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 . pre-mainé˜¶æ®µå½±å“å› ç´ 
/**
 1. åŠ¨æ€åº“è¶Šå¤šï¼Œå¯åŠ¨è¶Šæ…¢
 2. Objcç±»è¶Šå¥½,  å‡½æ•°è¶Šå¤šï¼Œå¯åŠ¨è¶Šæ…¢
 3. å¯æ‰§è¡Œæ–‡ä»¶è¶Šå¤§ï¼Œå¯åŠ¨è¶Šæ…¢
 4. Objcçš„loadæ–¹æ³•è¶Šå¤šï¼Œå¯åŠ¨è¶Šæ…¢
 */

/**
    struct thread_basic_info {
        time_value_t    user_time;      /* user run timeï¼ˆç”¨æˆ·è¿è¡Œæ—¶é•¿ï¼‰ */
        time_value_t    system_time;    /* system run timeï¼ˆç³»ç»Ÿè¿è¡Œæ—¶é•¿ï¼‰ */
        integer_t       cpu_usage;      /* scaled cpu usage percentageï¼ˆCPUä½¿ç”¨ç‡ï¼Œä¸Šé™1000ï¼‰ */
        policy_t        policy;         /* scheduling policy in effectï¼ˆæœ‰æ•ˆè°ƒåº¦ç­–ç•¥ï¼‰ */
        integer_t       run_state;      /* run state (è¿è¡ŒçŠ¶æ€ï¼Œè§ä¸‹) */
        integer_t       flags;          /* various flags (å„ç§å„æ ·çš„æ ‡è®°) */
        integer_t       suspend_count;  /* suspend count for threadï¼ˆçº¿ç¨‹æŒ‚èµ·æ¬¡æ•°ï¼‰ */
        integer_t       sleep_time;     /* number of seconds that thread
                                         *  has been sleepingï¼ˆä¼‘çœ æ—¶é—´ï¼‰ */
    };
 */

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OOM è¶…å‡ºäº†å†…å­˜åˆ†é…
/// æ”¶åˆ°ä½å†…å­˜è­¦å‘Šä¸ä¸€å®šä¼š Crashï¼Œå› ä¸ºæœ‰6ç§’é’Ÿçš„ç³»ç»Ÿåˆ¤æ–­æ—¶é—´ï¼Œ6ç§’å†…å†…å­˜ä¸‹é™äº†åˆ™ä¸ä¼š crashã€‚å‘ç”Ÿ OOM ä¹Ÿä¸ä¸€å®šä¼šæ”¶åˆ°ä½å†…å­˜è­¦å‘Š
/**
 åˆç†ä½¿ç”¨autoreleasepool, autoreleasepoolå¯¹è±¡æ˜¯åœ¨Runloopç»“æŸæ—¶é‡Šæ”¾ï¼Œåœ¨ARCä¸‹ï¼Œ å¦‚æœæˆ‘ä»¬ä¸æ–­çš„ç”³è¯·å†…å­˜ï¼Œ æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨çš„æ·»åŠ autoreleasepoolï¼Œ é¿å…çŸ­æ—¶é—´å†…å†…å­˜çŒ›æ¶¨å‘ç”ŸOOM
 å†…å­˜åˆ†é…:  mallocç”¨çš„æ˜¯ malloc_zone_malloc,  callocç”¨çš„æ˜¯malloc_zone_calloc
  åœ¨å¤„ç†å›¾ç‰‡ç¼©æ”¾æ—¶ï¼ŒImageIOå ç”¨å†…å­˜ä¼šæ¯”ç›´æ¥å¤„ç†å›¾ç‰‡ç¼©æ”¾å°
 */
</code></pre></div></div>
:ET