<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-16T15:06:24+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">风车大战骑士</title><subtitle>生活不止眼前的苟且，还有诗和远方</subtitle><entry><title type="html">vim的常用总结</title><link href="http://localhost:4000/Vim%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="vim的常用总结" /><published>2021-10-24T00:00:00+08:00</published><updated>2021-10-24T00:00:00+08:00</updated><id>http://localhost:4000/Vim%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/Vim%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">&lt;h4 id=&quot;vim的简介&quot;&gt;vim的简介&lt;/h4&gt;

&lt;p&gt;vim一项很好用的工具, 所有的 Unix Like 系统都会内建 vi 编辑器&lt;/p&gt;

&lt;p&gt;vi编辑器有三种模式&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;命令模式（Command mode）&lt;/li&gt;
  &lt;li&gt;输入模式（Insert mode）&lt;/li&gt;
  &lt;li&gt;底线命令模式（Last line mode）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三种模式的介绍&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命令模式( 敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令 )
&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输入模式
和正常的文本输入一样&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;底线命令模式
命令模式下按下:（英文冒号）就进入了底线命令模式， q 退出程序  w 保存文件， ESC键可随时退出底线命令模式&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;详细的内容可参考菜鸟教程&quot;&gt;详细的内容可参考菜鸟教程&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/linux/linux-vim.htmlhttps://www.runoob.com/linux/linux-vim.html&quot;&gt;vim详细教程&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="工具" /><summary type="html">vim的简介 vim一项很好用的工具, 所有的 Unix Like 系统都会内建 vi 编辑器 vi编辑器有三种模式 命令模式（Command mode） 输入模式（Insert mode） 底线命令模式（Last line mode） 三种模式的介绍 命令模式( 敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令 ) 输入模式 和正常的文本输入一样 底线命令模式 命令模式下按下:（英文冒号）就进入了底线命令模式， q 退出程序 w 保存文件， ESC键可随时退出底线命令模式 详细的内容可参考菜鸟教程 vim详细教程</summary></entry><entry><title type="html">APP卡顿总结</title><link href="http://localhost:4000/App%E5%8D%A1%E9%A1%BF%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="APP卡顿总结" /><published>2021-05-02T00:00:00+08:00</published><updated>2021-05-02T00:00:00+08:00</updated><id>http://localhost:4000/App%E5%8D%A1%E9%A1%BF%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/App%E5%8D%A1%E9%A1%BF%E6%80%BB%E7%BB%93/">&lt;h3 id=&quot;什么是卡顿&quot;&gt;什么是卡顿&lt;/h3&gt;
&lt;p&gt;卡顿就是在应用使用过程中出现界面不响应或者界面渲染粘滞的情况。而应用界面的渲染以及事件响应是在主线程完成的，出现卡顿的原因可以归结为主线程阻塞。&lt;/p&gt;

&lt;p&gt;在开发过程中，遇到的造成主线程阻塞的原因可能是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主线程在进行大量I/O操作：为了方便代码编写，直接在主线程去写入大量数据；&lt;/li&gt;
  &lt;li&gt;主线程在进行大量计算：代码编写不合理，主线程进行复杂计算；&lt;/li&gt;
  &lt;li&gt;大量UI绘制：界面过于复杂，UI绘制需要大量时间；&lt;/li&gt;
  &lt;li&gt;主线程在等锁：主线程需要获得锁A，但是当前某个子线程持有这个锁A，导致主线程不得不等待子线程完成任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何解决卡顿&quot;&gt;如何解决卡顿&lt;/h3&gt;
&lt;p&gt;捕获得到卡顿当时应用的主线程堆栈，有了堆栈，就可以知道主线程在什么函数哪一行代码卡住了，是在等什么锁，还是在进行I/O操作，或者是进行复杂计算。有了堆栈，就可以对问题进行针对性解决&lt;/p&gt;

&lt;h3 id=&quot;原理分析&quot;&gt;原理分析&lt;/h3&gt;
&lt;p&gt;主线程有一个 Runloop。Runloop 是一个 Event Loop 模型，让线程可以处于接收消息、处理事件、进入等待而不马上退出。在进入事件的前后，Runloop 会向注册的 Observer 通知相应的事件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa08c9eaeb63430680df2dfb6df0785c~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在 Runloop 的起始最开始和结束最末尾位置添加 Observer，从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a069194b10fa4d19901b506110517ed0~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主程序 Runloop 超时的阈值是 2 秒，子线程的检查周期是 1 秒。每隔 1 秒，子线程检查主线程的运行状态；如果检查到主线程 Runloop 运行超过 2 秒则认为是卡顿，并获得当前的线程快照。&lt;/p&gt;

&lt;p&gt;CPU 过高也可能导致应用出现卡顿，所以在子线程检查主线程状态的同时，如果检测到 CPU 占用过高，会捕获当前的线程快照保存到文件中。微信App认为，单核 CPU 的占用超过了 80%，此时的 CPU 占用就过高了&lt;/p&gt;

&lt;h3 id=&quot;监控app卡顿的三种方式&quot;&gt;监控APP卡顿的三种方式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;FPS&lt;/li&gt;
  &lt;li&gt;Runloop&lt;/li&gt;
  &lt;li&gt;子线程ping主线程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fps检测app卡顿&quot;&gt;FPS检测APP卡顿&lt;/h3&gt;
&lt;p&gt;通常情况下，屏幕会保持60hz/s的刷新速度，每次刷新时会发出一个屏幕刷新信号，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CADisplayLink&lt;/code&gt;允许我们注册一个与刷新信号同步的回调处理。可以通过屏幕刷新机制来展示fps值：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50db4f8cf6474910832bfd7fb14a3606~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;显示器中是固定的频率，比如iOS中是每秒60帧（60FPS），即每帧16.7ms。从上图中可以看出，每两个VSync信号之间有时间间隔（16.7ms），在这个时间内，CPU主线程计算布局，解码图片，创建视图，绘制文本，计算完成后将内容交给GPU，GPU变换，合成，渲染，放入帧缓冲区。假如16.7ms内，CPU和GPU没有来得及生产出一帧缓冲，那么这一帧会被丢弃，显示器就会保持不变，继续显示上一帧内容，这就将导致导致画面卡顿。所以无论CPU, GPU，哪个消耗时间过长，都会导致在16.7ms内无法生成一帧缓存&lt;/p&gt;

&lt;p&gt;主线程为了达到接近60fps的绘制效率，不能在UI线程有单个超过（1/60s≈16ms）的计算任务，否则就会卡顿&lt;/p&gt;

&lt;p&gt;我们可以用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CADisplayLink&lt;/code&gt;来检测FPS，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CADisplayLink&lt;/code&gt;则是使用帧率来作为时间间隔的单位&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setupDisplayLink {

   //创建CADisplayLink，并添加到当前run loop的NSRunLoopCommonModes
   _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkTicks:)];
   [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
}

- (void)linkTicks:(CADisplayLink *)link {

   //执行次数
   _scheduleTimes ++;

   //当前时间戳
   if(_timestamp == 0){
       _timestamp = link.timestamp;
   }
   
   CFTimeInterval timePassed = link.timestamp - _timestamp;

   if(timePassed &amp;gt;= 1.f)
       //fps
       CGFloat fps = _scheduleTimes/timePassed; 
       printf(&quot;fps:%.1f, timePassed:%f\n&quot;, fps, timePassed);

       //reset
       _timestamp = link.timestamp;
       _scheduleTimes = 0;
   }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;我们也可以通过Xcode中的Instruments中的Core Animation来监测FPS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;在上述FPS指示器中，如果将CADisplayLink放置于子线程的Runloop中，将会发生什么？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;答案是无论主线程有多么繁忙，GPU占用有多么高，FPS始终是60，原因是基于CADisplayLink的FPS指示器只能检测到当前RunLoop的FPS&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;runloop如何检测卡顿&quot;&gt;Runloop如何检测卡顿&lt;/h3&gt;

&lt;p&gt;由于runloop会调起同步屏幕刷新的callback，如果loop的间隔大于16.67ms，fps自然达不到60hz。而在一个loop当中存在多个阶段，可以监控每一个阶段停留了多长时间&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)startRunloopMonitorFreeze {
    
    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
       
        
       ///如果CFAbsoluteTimeGetCurrent() - 上一次的时间差 比阈值大，说明卡顿了，APP处于闲置状态常驻beforeWaiting状态，判断不准确
        
        
    });
    
    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种检测方式当APP处于闲置状态Runloop常驻beforeWaiting状态，判断不准确&lt;/p&gt;

&lt;h3 id=&quot;子线程检测主线程&quot;&gt;子线程检测主线程&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;退火算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了降低检测带来的性能损耗，我们为检测线程增加了退火算法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每次子线程检查到主线程卡顿，会先获得主线程的堆栈并保存到内存中（不会直接去获得线程快照保存到文件中）；&lt;/li&gt;
  &lt;li&gt;将获得的主线程堆栈与上次卡顿获得的主线程堆栈进行比对：
    &lt;ul&gt;
      &lt;li&gt;如果堆栈不同，则获得当前的线程快照并写入文件中；&lt;/li&gt;
      &lt;li&gt;如果相同则会跳过，并按照斐波那契数列将检查时间递增直到没有遇到卡顿或者主线程卡顿堆栈不一样。
这样，可以避免同一个卡顿写入多个文件的情况；避免检测线程遇到主线程卡死的情况下，不断写线程快照文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如何提前耗时堆栈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;子线程检测到主线程 Runloop 时，会获得当前的线程快照当做卡顿文件。但是这个当前的主线程堆栈不一定是最耗时的堆栈，不一定是导致主线程超时的主要原因。&lt;/p&gt;

&lt;p&gt;比如主线程分别先后执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;funcA()  funcB() funcC() funcD()&lt;/code&gt; 这几个方法, 子线程在检测到超出阈值时获得的线程快照，主线程的当前任务是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;funcD()&lt;/code&gt;但其实&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;funcB()&lt;/code&gt;才是耗时操作，导致主线程超时的主要原因。 卡顿监控通过主线程耗时堆栈提取来解决这个问题&lt;/p&gt;

&lt;p&gt;卡顿监控定时获取主线程堆栈，并将堆栈保存到内存的一个循环队列中。如下图，每间隔时间 t 获得一个堆栈，然后将堆栈保存到一个最大个数为 3 的循环队列中。有一个游标不断的指向最近的堆栈。&lt;/p&gt;

&lt;p&gt;微信的策略是每隔 50 毫秒获取一次主线程堆栈，保存最近 20 个主线程堆栈。这个会增加 3% 的 CPU 占用，内存占用可以忽略不计。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5a97bcaefb64ec6b8627b6237cff9cc~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当主线程检测到卡顿时，通过对保存到循坏队列中的堆栈进行回溯，获取最近最耗时堆栈。&lt;/p&gt;

&lt;p&gt;如下图，检测到卡顿时，内存的循环队列中记录了最近的20个主线程堆栈，需要从中找出最近最耗时的堆栈。卡顿监控用如下特征找出最近最耗时堆栈：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以栈顶函数为特征，认为栈顶函数相同的即整个堆栈是相同的；&lt;/li&gt;
  &lt;li&gt;取堆栈的间隔是相同的，堆栈的重复次数近似作为堆栈的调用耗时，重复越多，耗时越多；&lt;/li&gt;
  &lt;li&gt;重复次数相同的堆栈可能很有多个，取最近的一个最耗时堆栈。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7062802f46c649ab853938f2372c8d40~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">什么是卡顿 卡顿就是在应用使用过程中出现界面不响应或者界面渲染粘滞的情况。而应用界面的渲染以及事件响应是在主线程完成的，出现卡顿的原因可以归结为主线程阻塞。 在开发过程中，遇到的造成主线程阻塞的原因可能是： 主线程在进行大量I/O操作：为了方便代码编写，直接在主线程去写入大量数据； 主线程在进行大量计算：代码编写不合理，主线程进行复杂计算； 大量UI绘制：界面过于复杂，UI绘制需要大量时间； 主线程在等锁：主线程需要获得锁A，但是当前某个子线程持有这个锁A，导致主线程不得不等待子线程完成任务。 如何解决卡顿 捕获得到卡顿当时应用的主线程堆栈，有了堆栈，就可以知道主线程在什么函数哪一行代码卡住了，是在等什么锁，还是在进行I/O操作，或者是进行复杂计算。有了堆栈，就可以对问题进行针对性解决 原理分析 主线程有一个 Runloop。Runloop 是一个 Event Loop 模型，让线程可以处于接收消息、处理事件、进入等待而不马上退出。在进入事件的前后，Runloop 会向注册的 Observer 通知相应的事件 在 Runloop 的起始最开始和结束最末尾位置添加 Observer，从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。 主程序 Runloop 超时的阈值是 2 秒，子线程的检查周期是 1 秒。每隔 1 秒，子线程检查主线程的运行状态；如果检查到主线程 Runloop 运行超过 2 秒则认为是卡顿，并获得当前的线程快照。 CPU 过高也可能导致应用出现卡顿，所以在子线程检查主线程状态的同时，如果检测到 CPU 占用过高，会捕获当前的线程快照保存到文件中。微信App认为，单核 CPU 的占用超过了 80%，此时的 CPU 占用就过高了 监控APP卡顿的三种方式 FPS Runloop 子线程ping主线程 FPS检测APP卡顿 通常情况下，屏幕会保持60hz/s的刷新速度，每次刷新时会发出一个屏幕刷新信号，CADisplayLink允许我们注册一个与刷新信号同步的回调处理。可以通过屏幕刷新机制来展示fps值： 显示器中是固定的频率，比如iOS中是每秒60帧（60FPS），即每帧16.7ms。从上图中可以看出，每两个VSync信号之间有时间间隔（16.7ms），在这个时间内，CPU主线程计算布局，解码图片，创建视图，绘制文本，计算完成后将内容交给GPU，GPU变换，合成，渲染，放入帧缓冲区。假如16.7ms内，CPU和GPU没有来得及生产出一帧缓冲，那么这一帧会被丢弃，显示器就会保持不变，继续显示上一帧内容，这就将导致导致画面卡顿。所以无论CPU, GPU，哪个消耗时间过长，都会导致在16.7ms内无法生成一帧缓存 主线程为了达到接近60fps的绘制效率，不能在UI线程有单个超过（1/60s≈16ms）的计算任务，否则就会卡顿 我们可以用CADisplayLink来检测FPS，CADisplayLink则是使用帧率来作为时间间隔的单位 - (void)setupDisplayLink { //创建CADisplayLink，并添加到当前run loop的NSRunLoopCommonModes _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkTicks:)]; [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; } - (void)linkTicks:(CADisplayLink *)link { //执行次数 _scheduleTimes ++; //当前时间戳 if(_timestamp == 0){ _timestamp = link.timestamp; } CFTimeInterval timePassed = link.timestamp - _timestamp; if(timePassed &amp;gt;= 1.f) //fps CGFloat fps = _scheduleTimes/timePassed; printf(&quot;fps:%.1f, timePassed:%f\n&quot;, fps, timePassed); //reset _timestamp = link.timestamp; _scheduleTimes = 0; } } 我们也可以通过Xcode中的Instruments中的Core Animation来监测FPS 在上述FPS指示器中，如果将CADisplayLink放置于子线程的Runloop中，将会发生什么？ 答案是无论主线程有多么繁忙，GPU占用有多么高，FPS始终是60，原因是基于CADisplayLink的FPS指示器只能检测到当前RunLoop的FPS Runloop如何检测卡顿 由于runloop会调起同步屏幕刷新的callback，如果loop的间隔大于16.67ms，fps自然达不到60hz。而在一个loop当中存在多个阶段，可以监控每一个阶段停留了多长时间 - (void)startRunloopMonitorFreeze { CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { ///如果CFAbsoluteTimeGetCurrent() - 上一次的时间差 比阈值大，说明卡顿了，APP处于闲置状态常驻beforeWaiting状态，判断不准确 }); CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes); } 这种检测方式当APP处于闲置状态Runloop常驻beforeWaiting状态，判断不准确 子线程检测主线程 退火算法 为了降低检测带来的性能损耗，我们为检测线程增加了退火算法： 每次子线程检查到主线程卡顿，会先获得主线程的堆栈并保存到内存中（不会直接去获得线程快照保存到文件中）； 将获得的主线程堆栈与上次卡顿获得的主线程堆栈进行比对： 如果堆栈不同，则获得当前的线程快照并写入文件中； 如果相同则会跳过，并按照斐波那契数列将检查时间递增直到没有遇到卡顿或者主线程卡顿堆栈不一样。 这样，可以避免同一个卡顿写入多个文件的情况；避免检测线程遇到主线程卡死的情况下，不断写线程快照文件。 如何提前耗时堆栈 子线程检测到主线程 Runloop 时，会获得当前的线程快照当做卡顿文件。但是这个当前的主线程堆栈不一定是最耗时的堆栈，不一定是导致主线程超时的主要原因。 比如主线程分别先后执行funcA() funcB() funcC() funcD() 这几个方法, 子线程在检测到超出阈值时获得的线程快照，主线程的当前任务是 funcD()但其实funcB()才是耗时操作，导致主线程超时的主要原因。 卡顿监控通过主线程耗时堆栈提取来解决这个问题 卡顿监控定时获取主线程堆栈，并将堆栈保存到内存的一个循环队列中。如下图，每间隔时间 t 获得一个堆栈，然后将堆栈保存到一个最大个数为 3 的循环队列中。有一个游标不断的指向最近的堆栈。 微信的策略是每隔 50 毫秒获取一次主线程堆栈，保存最近 20 个主线程堆栈。这个会增加 3% 的 CPU 占用，内存占用可以忽略不计。 当主线程检测到卡顿时，通过对保存到循坏队列中的堆栈进行回溯，获取最近最耗时堆栈。 如下图，检测到卡顿时，内存的循环队列中记录了最近的20个主线程堆栈，需要从中找出最近最耗时的堆栈。卡顿监控用如下特征找出最近最耗时堆栈： 以栈顶函数为特征，认为栈顶函数相同的即整个堆栈是相同的； 取堆栈的间隔是相同的，堆栈的重复次数近似作为堆栈的调用耗时，重复越多，耗时越多； 重复次数相同的堆栈可能很有多个，取最近的一个最耗时堆栈。</summary></entry><entry><title type="html">Jenkins总结笔记</title><link href="http://localhost:4000/Jenkins%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="Jenkins总结笔记" /><published>2021-02-15T00:00:00+08:00</published><updated>2021-02-15T00:00:00+08:00</updated><id>http://localhost:4000/Jenkins%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/Jenkins%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/">&lt;h3 id=&quot;安装jenkins&quot;&gt;安装Jenkins&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;安装包安装&lt;/li&gt;
  &lt;li&gt;HomeBrew安装&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;安装包安装&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于Jenkins 依赖于Java，所以在安装Jenkins前，需要先检查是否已安装Java环境。 在终端输入命令进行检测：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ java -version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后前往&lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins官网&lt;/a&gt;下载安装包安装&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;homeBrew安装&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;初始化jenkins&quot;&gt;初始化Jenkins&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在终端输入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jenkins&lt;/code&gt;启动服务&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在浏览器中输入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:8080&lt;/code&gt;中进行访问
  &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/19/16fbb6f6dc5c1eba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;依照图中描述在终端输入 cat + 密码路径，获取密码复制下一步&lt;/li&gt;
  &lt;li&gt;等待插件安装完成。&lt;/li&gt;
  &lt;li&gt;配置完管理员账户，就成功安装完成啦&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;安装插件&quot;&gt;安装插件&lt;/h3&gt;

&lt;h3 id=&quot;新建任务&quot;&gt;新建任务&lt;/h3&gt;

&lt;h3 id=&quot;打包脚本&quot;&gt;打包脚本&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#!/bin/sh
export LANG=en_US.UTF-8

# 1.设置配置标识,编译环境(根据需要自行填写 release ｜ debug )
configuration=&quot;debug&quot;

# 工程名(根据项目自行填写)
APP_NAME=&quot;项目名&quot;

# TARGET名称（根据项目自行填写）
TARGET_NAME=&quot;项目名&quot;

# ipa前缀（根据项目自行填写）
IPA_NAME=&quot;项目名&quot;

# 工程根目录#工程源码目录(这里的${WORKSPACE}是jenkins的内置变量表示(jenkins job的路径):/Users/plz/.jenkins/workspace/TestDome/)
# ${WORKSPACE}/TestDome/ 中的TestDome根据你的项目自行修改
CODE_PATH=&quot;${WORKSPACE}/xx/${TARGET_NAME}&quot;
echo &quot;-------------- CODE_PATH: ${CODE_PATH}&quot;

# info.plist路径
project_infoplist_path= &quot;${CODE_PATH}/${TARGET_NAME}/Info.plist&quot;

# 取版本号
bundleShortVersion= $(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;${project_infoplist_path}&quot;)
# bundleVersion= $(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;${project_infoplist_path}&quot;)

echo &quot;------- info plist path : ${project_infoplist_path}&quot;
echo &quot;------- bundleShortVersion : ${bundleShortVersion}&quot;
# $echo &quot;------- bundleVersion : ${bundleVersion}&quot;

# 日期
DATE=$(date +%Y%m%d%H%M%S)
# 工程文件路径
ARCHIVE_NAME=&quot;${APP_NAME}_${DATE}.xcarchive&quot;
# 存放ipa的文件夹名称（根据自己的喜好自行修改）
IPANAME=&quot;${IPA_NAME}_IPA&quot;

# 要上传的ipa文件路径 ${username} 需要换成自己的用户名
ROOT_PATH=&quot;/Users/wanglei/Desktop/Jenkins&quot;

ARCHIVE_PATH=&quot;${ROOT_PATH}/Archive/${ARCHIVE_NAME}&quot;

IPA_PATH=&quot;${ROOT_PATH}/Export/${IPANAME}&quot;

echo &quot;-------------- ARCHIVE_PATH: ${ARCHIVE_PATH}&quot;
echo &quot;-------------- IPA_PATH: ${IPA_PATH}&quot;


# 导包方式(这里需要根据需要手动配置:AdHoc/AppStore/Enterprise/Development)
EXPORT_METHOD=&quot;AdHoc&quot;
# 导包方式配置文件路径(这里需要手动创建对应的XXXExportOptionsPlist.plist文件，并将文件复制到根目录下[我这里在源项目的根目录下又新建了ExportPlist文件夹专门放ExportPlist文件])
if test &quot;$EXPORT_METHOD&quot; = &quot;AdHoc&quot;; then
    EXPORT_METHOD_PLIST_PATH=${CODE_PATH}/ExportOptions.plist
elif test &quot;$EXPORT_METHOD&quot; = &quot;AppStore&quot;; then
    EXPORT_METHOD_PLIST_PATH=${CODE_PATH}/ExportOptions/AppStoreExportOptios.plist
elif test &quot;$EXPORT_METHOD&quot; = &quot;Enterprise&quot;; then
    EXPORT_METHOD_PLIST_PATH=${CODE_PATH}/ExportOptions/EnterpriseExportOptions.plist
else
    EXPORT_METHOD_PLIST_PATH=${CODE_PATH}/ExportOptions/DevelopmentExportOptions.plist
fi

echo &quot;-------------- EXPORT_METHOD_PLIST_PATH: ${EXPORT_METHOD_PLIST_PATH}&quot;

# 指ipa定输出文件夹,如果有删除后再创建，如果没有就直接创建
if test -d ${IPA_PATH}; then
    &quot;-------------- 删除:IPA Path : ${IPA_PATH}&quot;
    rm -rf ${IPA_PATH}
    mkdir ${IPA_PATH}
    &quot;-------------- 创建:IPA Path : ${IPA_PATH}&quot;
else
    mkdir -pv ${IPA_PATH}
    &quot;-------------- 创建:IPA Path : ${IPA_PATH}&quot;
fi

# 进入工程源码根目录
cd &quot;${CODE_PATH}&quot;

echo &quot;-------------- 安装Pod Code Path: ${CODE_PATH}&quot;
# 执行pod
pod install --verbose --no-repo-update

#mkdir -p build

# 清除工程
echo &quot;-------------- Clean项目 执行Shell: xcodebuild clean -workspace ${APP_NAME}.xcworkspace -scheme ${APP_NAME} -configuration ${configuration}&quot;
xcodebuild clean -workspace ${APP_NAME}.xcworkspace -scheme ${APP_NAME} -configuration ${configuration}

# 将app打包成xcarchive格式文件
echo &quot;-------------- archive项目 执行Shell: xcodebuild archive -workspace ${APP_NAME}.xcworkspace -scheme ${APP_NAME} -configuration ${configuration} -archivePath ${ARCHIVE_PATH}&quot;
xcodebuild archive -workspace ${APP_NAME}.xcworkspace -scheme ${APP_NAME} -configuration ${configuration} -archivePath ${ARCHIVE_PATH}

# 将xcarchive格式文件打包成ipa
echo &quot;-------------- 导出ipa包 执行Shell: xcodebuild -exportArchive -archivePath ${ARCHIVE_PATH} -exportPath &quot;${IPA_PATH}&quot; -exportOptionsPlist ${EXPORT_METHOD_PLIST_PATH} -allowProvisioningUpdates&quot;
xcodebuild -exportArchive -archivePath ${ARCHIVE_PATH} -exportPath &quot;${IPA_PATH}&quot; -exportOptionsPlist ${EXPORT_METHOD_PLIST_PATH} -allowProvisioningUpdates

# 删除工程文件
# echo &quot;+++++++++删除工程文件+++++++++&quot;
# rm -rf $ARCHIVE_PATH


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Linux" /><category term="iOS" /><summary type="html">安装Jenkins 安装包安装 HomeBrew安装 安装包安装 由于Jenkins 依赖于Java，所以在安装Jenkins前，需要先检查是否已安装Java环境。 在终端输入命令进行检测： $ java -version 然后前往Jenkins官网下载安装包安装 homeBrew安装 brew install jenkins 初始化Jenkins 在终端输入jenkins启动服务 在浏览器中输入http://localhost:8080中进行访问 依照图中描述在终端输入 cat + 密码路径，获取密码复制下一步 等待插件安装完成。 配置完管理员账户，就成功安装完成啦 安装插件 新建任务 打包脚本 ``` #!/bin/sh export LANG=en_US.UTF-8 1.设置配置标识,编译环境(根据需要自行填写 release ｜ debug ) configuration=”debug” 工程名(根据项目自行填写) APP_NAME=”项目名” TARGET名称（根据项目自行填写） TARGET_NAME=”项目名” ipa前缀（根据项目自行填写） IPA_NAME=”项目名” 工程根目录#工程源码目录(这里的${WORKSPACE}是jenkins的内置变量表示(jenkins job的路径):/Users/plz/.jenkins/workspace/TestDome/) ${WORKSPACE}/TestDome/ 中的TestDome根据你的项目自行修改 CODE_PATH=”${WORKSPACE}/xx/${TARGET_NAME}” echo “</summary></entry><entry><title type="html">量化金融的总结</title><link href="http://localhost:4000/%E9%87%8F%E5%8C%96%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E6%A0%87/" rel="alternate" type="text/html" title="量化金融的总结" /><published>2020-12-30T00:00:00+08:00</published><updated>2020-12-30T00:00:00+08:00</updated><id>http://localhost:4000/%E9%87%8F%E5%8C%96%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E6%A0%87</id><content type="html" xml:base="http://localhost:4000/%E9%87%8F%E5%8C%96%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E6%A0%87/">&lt;h3 id=&quot;常见的指标&quot;&gt;常见的指标&lt;/h3&gt;

&lt;h4 id=&quot;ma--简单移动平均数&quot;&gt;MA  简单移动平均数&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;移动平均线 [1]  常用线有5天、10天、30天、60天、120天和240天的指标。其中，5天和10天的短期移动平均线，是短线操作的参照指标，称做日均线指标；30天和60天的是中期均线指标，称做季均线指标；120天、240天的是长期均线指标，称做年均线指标&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;移动平均数分为MA（简单移动平均数）&lt;/li&gt;
  &lt;li&gt;EMA（指数移动平均数）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其计算公式如下：［C为收盘价，N为周期数］：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MA（N）=（C1+C2+……CN）/N
MA（7）=（C1+C2+……CN）/7
MA（30）=（C1+C2+……CN）/30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;EMA（N）= 2 /（N + 1）*（C - 昨日EMA）+ 昨日EMA&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// 12日EMA的算式:
EMA（12）= 昨日EMA（12 * 11 / 13 + C * 2 / 13 ＝ (C － 昨日的EMA) × 0.1538 ＋ 昨日的EMA；   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;即为MACD指标中的快线 - 快速平滑移动平均线；&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// 26日EMA的算式为
EMA（26）= 昨日EMA（26）* 25 /27 + C * 2 / 27；
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;关键的一点是：新股上市首日，其DIFF, DEA以及MACD都为0，因为当日不存在前一日，无法做迭代。而计算新股上市第二日的EMA时，前一日的EMA需要用收盘价（而非0）来计算。另外，需要注意，计算过程小数点后四舍五入保留4位小数，最后显示的时候四舍五入保留3位小数。&lt;/p&gt;

&lt;p&gt;具体计算公式及例子如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EMA（12）= 前一日EMA（12）× 11 / 13 ＋ 今日收盘价 × 2 / 13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EMA（26）= 前一日EMA（26）× 25 / 27 ＋ 今日收盘价 × 2 / 27
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DIFF = 今日EMA（12）- 今日EMA（26）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEA（MACD）= 前一日DEA × 8 / 10 ＋ 今日DIF × 2 / 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BAR = 2 × (DIFF－DEA)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;20091218日：
新股上市，DIFF = 0, DEA = 0, MACD = 0，收盘价55.01&lt;/p&gt;

&lt;p&gt;20091219日：
收盘价53.7&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EMA（12）=55.01 + (53.7 - 55.01) × 2 / 13 = 54.8085

EMA（26 = 55.01 + (53.7 - 55.01) × 2 / 27 = 54.913

DIFF = EMA（12）- EMA（26）= 54.8085 - 54.913 = -0.1045 （-0.104？）

DEA = 0 + (-0.1045) X 2 / 10 = -0.0209

BAR = 2 * ((-0.1045) -(-0.0209)) = -0.1672

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;boll&quot;&gt;BOLL&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;定义：布林线指标，即BOLL指标，其英文全称是“Bollinger Bands”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;描述：其利用统计原理，求出股价的标准差及其信赖区间，从而确定股价的波动范围及未来走势，利用波带显示股价的安全高低价位，因而也被称为布林带。其上下限范围不固定，随股价的滚动而变化。布林指标和麦克指标MIKE一样同属路径指标，股价波动在上限和下限的区间之内，这条带状区的宽窄，随着股价波动幅度的大小而变化，股价涨跌幅度加大时，带状区变宽，涨跌幅度狭小盘整时，带状区则变窄。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;公式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;中轨线 = N日的移动平均线&lt;/li&gt;
  &lt;li&gt;上轨线 = 中轨线 + 两倍的标准差&lt;/li&gt;
  &lt;li&gt;下轨线 = 中轨线 － 两倍的标准差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;计算过程：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;计算MA：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MA = N日内的收盘价之和 ÷ N&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;计算标准差MD&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MD = 平方根（N-1）日的（C－MA）的两次方之和除以N&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;计算MB、UP、DN线&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// K为参数，可根据股票的特性来做相应的调整，一般默认为2，N一般选择20天

MB =（N－1）日的MA

UP = MB + k × MD

DN = MB－k × MD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;应用：布林口由缩口变张口，那么可以往着张口的趋势布局。趋势分两种，一种是下跌，一种是上涨。当K线站上中轨，并且伴随着成交量放量增长，则出现买点。&lt;/p&gt;</content><author><name></name></author><category term="金融" /><summary type="html">常见的指标 MA 简单移动平均数 移动平均线 [1] 常用线有5天、10天、30天、60天、120天和240天的指标。其中，5天和10天的短期移动平均线，是短线操作的参照指标，称做日均线指标；30天和60天的是中期均线指标，称做季均线指标；120天、240天的是长期均线指标，称做年均线指标 移动平均数分为MA（简单移动平均数） EMA（指数移动平均数） 其计算公式如下：［C为收盘价，N为周期数］： MA（N）=（C1+C2+……CN）/N MA（7）=（C1+C2+……CN）/7 MA（30）=（C1+C2+……CN）/30 EMA（N）= 2 /（N + 1）*（C - 昨日EMA）+ 昨日EMA /// 12日EMA的算式: EMA（12）= 昨日EMA（12 * 11 / 13 + C * 2 / 13 ＝ (C － 昨日的EMA) × 0.1538 ＋ 昨日的EMA； 即为MACD指标中的快线 - 快速平滑移动平均线； /// 26日EMA的算式为 EMA（26）= 昨日EMA（26）* 25 /27 + C * 2 / 27； 关键的一点是：新股上市首日，其DIFF, DEA以及MACD都为0，因为当日不存在前一日，无法做迭代。而计算新股上市第二日的EMA时，前一日的EMA需要用收盘价（而非0）来计算。另外，需要注意，计算过程小数点后四舍五入保留4位小数，最后显示的时候四舍五入保留3位小数。 具体计算公式及例子如下： EMA（12）= 前一日EMA（12）× 11 / 13 ＋ 今日收盘价 × 2 / 13 EMA（26）= 前一日EMA（26）× 25 / 27 ＋ 今日收盘价 × 2 / 27 DIFF = 今日EMA（12）- 今日EMA（26） DEA（MACD）= 前一日DEA × 8 / 10 ＋ 今日DIF × 2 / 10 BAR = 2 × (DIFF－DEA) 示例： 20091218日： 新股上市，DIFF = 0, DEA = 0, MACD = 0，收盘价55.01 20091219日： 收盘价53.7 EMA（12）=55.01 + (53.7 - 55.01) × 2 / 13 = 54.8085 EMA（26 = 55.01 + (53.7 - 55.01) × 2 / 27 = 54.913 DIFF = EMA（12）- EMA（26）= 54.8085 - 54.913 = -0.1045 （-0.104？） DEA = 0 + (-0.1045) X 2 / 10 = -0.0209 BAR = 2 * ((-0.1045) -(-0.0209)) = -0.1672 BOLL 定义：布林线指标，即BOLL指标，其英文全称是“Bollinger Bands”. 描述：其利用统计原理，求出股价的标准差及其信赖区间，从而确定股价的波动范围及未来走势，利用波带显示股价的安全高低价位，因而也被称为布林带。其上下限范围不固定，随股价的滚动而变化。布林指标和麦克指标MIKE一样同属路径指标，股价波动在上限和下限的区间之内，这条带状区的宽窄，随着股价波动幅度的大小而变化，股价涨跌幅度加大时，带状区变宽，涨跌幅度狭小盘整时，带状区则变窄。 公式： 中轨线 = N日的移动平均线 上轨线 = 中轨线 + 两倍的标准差 下轨线 = 中轨线 － 两倍的标准差 计算过程： 计算MA： MA = N日内的收盘价之和 ÷ N 计算标准差MD MD = 平方根（N-1）日的（C－MA）的两次方之和除以N 计算MB、UP、DN线 /// K为参数，可根据股票的特性来做相应的调整，一般默认为2，N一般选择20天 MB =（N－1）日的MA UP = MB + k × MD DN = MB－k × MD 应用：布林口由缩口变张口，那么可以往着张口的趋势布局。趋势分两种，一种是下跌，一种是上涨。当K线站上中轨，并且伴随着成交量放量增长，则出现买点。</summary></entry><entry><title type="html">CPU内存总结</title><link href="http://localhost:4000/CPU%E5%86%85%E5%AD%98%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="CPU内存总结" /><published>2020-11-09T00:00:00+08:00</published><updated>2020-11-09T00:00:00+08:00</updated><id>http://localhost:4000/CPU%E5%86%85%E5%AD%98%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/CPU%E5%86%85%E5%AD%98%E6%80%BB%E7%BB%93/">&lt;h2 id=&quot;app-的-cpu-占用率&quot;&gt;&lt;strong&gt;APP 的 CPU 占用率&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如何获取CPU的占用率:&lt;/strong&gt;   应用作为进程运行时，包含了多个不同的线程，如果我们能获取应用的所有线程占用 CPU 的情况，也就能知道应用的 CPU 占用率&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，而 XNU 是 Darwin 的内核，它是“X is not UNIX”的缩写，是一个混合内核，由 Mach 微内核和 BSD 组成。Mach 内核是轻量级的平台，只能完成操作系统最基本的职责，比如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，例如文件操作和设备访问，都由 BSD 层实现&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/593144fc59034493b88f869a6fc9293e~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与 Mac OS X 类似，iOS 的线程技术也是基于 Mach 线程技术实现的，在 Mach 层中 thread_basic_info 结构体提供了线程的基本信息&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct thread_basic_info {
        time_value_t    user_time;      /* user run time */
        time_value_t    system_time;    /* system run time */
        integer_t       cpu_usage;      /* scaled cpu usage percentage */
        policy_t        policy;         /* scheduling policy in effect */
        integer_t       run_state;      /* run state (see below) */
        integer_t       flags;          /* various flags (see below) */
        integer_t       suspend_count;  /* suspend count for thread */
        integer_t       sleep_time;     /* number of seconds that thread
                                           has been sleeping */
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Mach task 可以看作一个机器无关的 thread 执行环境的抽象 一个 task 包含它的线程列表。内核提供了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_threads&lt;/code&gt; API 调用获取指定 task 的线程列表，然后可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info&lt;/code&gt; API 调用来查询指定线程的信息，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info&lt;/code&gt; API 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_act.h&lt;/code&gt; 中定义&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kern_return_t task_threads (
    task_t target_task,
    thread_act_array_t *act_list,
    mach_msg_type_number_t *act_listCnt
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_threads&lt;/code&gt; 将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target_task&lt;/code&gt; 任务中的所有线程保存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;act_list&lt;/code&gt; 数组中，数组中包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;act_listCnt&lt;/code&gt; 个条目。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kern_return_t thread_info
(
	thread_act_t target_act,
	thread_flavor_t flavor,
	thread_info_t thread_info_out,
	mach_msg_type_number_t *thread_info_outCnt
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info&lt;/code&gt; 查询 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flavor&lt;/code&gt; 指定的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread&lt;/code&gt; 信息，将信息返回到长度为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info_outCnt&lt;/code&gt; 字节的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info_out&lt;/code&gt; 缓存区中&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;获取当前应用的 CPU 占用率的实现如下：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;mach/mach.h&amp;gt;
#import &amp;lt;assert.h&amp;gt;

+ (CGFloat)appCpuUsage {

    task_info_data_t tinfo;
    mach_msg_type_number_t task_info_count = TASK_INFO_MAX;
    /// THREAD_BASIC_INFO ，使用这个类型会返回线程的基本信息，定义在 thread_basic_info_t 结构体，包含了用户和系统的运行时间，运行状态和调度优先级
    kern_return_t kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)tinfo, &amp;amp;task_info_count);
    if (kr != KERN_SUCCESS) {
        return -1;
    }
    
    thread_array_t         thread_list;
    mach_msg_type_number_t thread_count;
    
    thread_info_data_t     thinfo;
    mach_msg_type_number_t thread_info_count;
    
    thread_basic_info_t basic_info_th;
    
     // mach_task_self()，表示获取当前的 Mach task
    kr = task_threads(mach_task_self(), &amp;amp;thread_list, &amp;amp;thread_count);
    if (kr != KERN_SUCCESS) {
        return -1;
    }
    
    long total_time     = 0;
    long total_userTime = 0;
    CGFloat total_cpu   = 0;
    int j;
    
    // for each thread
    for (j = 0; j &amp;lt; (int)thread_count; j++) {
        thread_info_count = THREAD_INFO_MAX;
        kr = thread_info(thread_list[j], THREAD_BASIC_INFO,
                         (thread_info_t)thinfo, &amp;amp;thread_info_count);
        if (kr != KERN_SUCCESS) {
            return -1;
        }
        
        basic_info_th = (thread_basic_info_t)thinfo;
        
        if (!(basic_info_th-&amp;gt;flags &amp;amp; TH_FLAGS_IDLE)) {
            total_time     = total_time + basic_info_th-&amp;gt;user_time.seconds + basic_info_th-&amp;gt;system_time.seconds;
            total_userTime = total_userTime + basic_info_th-&amp;gt;user_time.microseconds + basic_info_th-&amp;gt;system_time.microseconds;
            total_cpu      = total_cpu + basic_info_th-&amp;gt;cpu_usage / (float)TH_USAGE_SCALE * kMaxPercent;
        }
    }
    
    /// 防止出现内存泄漏必须调用它
    kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));
    assert(kr == KERN_SUCCESS);
    
    return total_cpu;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cpu-核数&quot;&gt;CPU 核数&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (NSUInteger)cpuNumber {
    return [NSProcessInfo processInfo].activeProcessorCount;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cpu-频率&quot;&gt;CPU 频率&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;CPU 频率，就是 CPU 的时钟频率， 是 CPU 运算时的工作的频率（1秒内发生的同步脉冲数）的简称。单位是 Hz，它决定移动设备的运行速度。
在 iOS 中与 CPU 频率相关的性能指标有三个：CPU 频率，CPU 最大频率 和 CPU 最小频率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (NSUInteger)getSysInfo:(uint)typeSpecifier {
    size_t size = sizeof(int);
    int results;
    int mib[2] = {CTL_HW, typeSpecifier};
    sysctl(mib, 2, &amp;amp;results, &amp;amp;size, NULL, 0);
    return (NSUInteger)results;
}

+ (NSUInteger)getCpuFrequency {
    return [self getSysInfo:HW_CPU_FREQ];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ramrandom-access-memory&quot;&gt;RAM(Random Access Memory)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;物理内存（RAM）与 CPU 一样都是系统中最稀少的资源，也是最有可能产生竞争的资源，应用内存与性能直接相关 - 通常是以牺牲别的应用为代价。 不像 PC 端，iOS 没有交换空间作为备选资源，这就使得内存资源尤为重要。事实上，在 iOS 中就有 Jetsam 机制负责处理系统低 RAM 事件，Jetsam 是一种类似 Linux 的 Out-Of-Memory(Killer) 的机制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;app使用的内存&quot;&gt;App使用的内存&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mach_task_basic_info&lt;/code&gt; 结构体存储了 Mach task 的内存使用信息，其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resident_size&lt;/code&gt; 就是应用使用的物理内存大小，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;virtual_size&lt;/code&gt; 是虚拟内存大小。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define MACH_TASK_BASIC_INFO     20         /* always 64-bit basic info */
struct mach_task_basic_info {
        mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */
        mach_vm_size_t  resident_size;      /* resident memory size (bytes) */
        mach_vm_size_t  resident_size_max;  /* maximum resident memory size (bytes) */
        time_value_t    user_time;          /* total user run time for
                                               terminated threads */
        time_value_t    system_time;        /* total system run time for
                                               terminated threads */
        policy_t        policy;             /* default policy for new threads */
        integer_t       suspend_count;      /* suspend count for task */
};

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_info&lt;/code&gt; API 根据指定的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flavor&lt;/code&gt; 类型返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target_task&lt;/code&gt; 的信息。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kern_return_t task_info
(
	task_name_t target_task,
	task_flavor_t flavor,
	task_info_t task_info_out,
	mach_msg_type_number_t *task_info_outCnt
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;获取APP内存使用量&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 获取APP内存使用量
 
 @return byte
 */
+ (unsigned long long)getAppRAMUsage {
    
    struct mach_task_basic_info info;
    mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;
    
    kern_return_t kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&amp;amp;info, &amp;amp;count);
    if (kr != KERN_SUCCESS) {
        return 0;
    }
    return info.resident_size;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;获取系统内存总量&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 获取系统内存总量
 
 @return byte
 */
+ (unsigned long long)getSystemRAMTotal {
    return [NSProcessInfo processInfo].physicalMemory;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;获取当前设备的内存使用情况&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (CGFloat)getUsedMemory {
    
    size_t length = 0;
    int mib[6] = {0};
    
    int pagesize = 0;
    mib[0] = CTL_HW;
    mib[1] = HW_PAGESIZE;
    length = sizeof(pagesize);
    if (sysctl(mib, 2, &amp;amp;pagesize, &amp;amp;length, NULL, 0) &amp;lt; 0) {
        return 0;
    }
    
    mach_msg_type_number_t count = HOST_VM_INFO_COUNT;
    
    vm_statistics_data_t vmstat;
    
    if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;amp;vmstat, &amp;amp;count) != KERN_SUCCESS) {
        return 0;
    }
    
    int wireMem = vmstat.wire_count * pagesize;
    int activeMem = vmstat.active_count * pagesize;
    return wireMem + activeMem;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">APP 的 CPU 占用率 如何获取CPU的占用率: 应用作为进程运行时，包含了多个不同的线程，如果我们能获取应用的所有线程占用 CPU 的情况，也就能知道应用的 CPU 占用率 iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，而 XNU 是 Darwin 的内核，它是“X is not UNIX”的缩写，是一个混合内核，由 Mach 微内核和 BSD 组成。Mach 内核是轻量级的平台，只能完成操作系统最基本的职责，比如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，例如文件操作和设备访问，都由 BSD 层实现 与 Mac OS X 类似，iOS 的线程技术也是基于 Mach 线程技术实现的，在 Mach 层中 thread_basic_info 结构体提供了线程的基本信息 struct thread_basic_info { time_value_t user_time; /* user run time */ time_value_t system_time; /* system run time */ integer_t cpu_usage; /* scaled cpu usage percentage */ policy_t policy; /* scheduling policy in effect */ integer_t run_state; /* run state (see below) */ integer_t flags; /* various flags (see below) */ integer_t suspend_count; /* suspend count for thread */ integer_t sleep_time; /* number of seconds that thread has been sleeping */ }; Mach task 可以看作一个机器无关的 thread 执行环境的抽象 一个 task 包含它的线程列表。内核提供了 task_threads API 调用获取指定 task 的线程列表，然后可以通过 thread_info API 调用来查询指定线程的信息，thread_info API 在 thread_act.h 中定义 kern_return_t task_threads ( task_t target_task, thread_act_array_t *act_list, mach_msg_type_number_t *act_listCnt ); task_threads 将 target_task 任务中的所有线程保存在 act_list 数组中，数组中包含 act_listCnt 个条目。 kern_return_t thread_info ( thread_act_t target_act, thread_flavor_t flavor, thread_info_t thread_info_out, mach_msg_type_number_t *thread_info_outCnt ); thread_info 查询 flavor 指定的 thread 信息，将信息返回到长度为 thread_info_outCnt 字节的 thread_info_out 缓存区中 获取当前应用的 CPU 占用率的实现如下： #import &amp;lt;mach/mach.h&amp;gt; #import &amp;lt;assert.h&amp;gt; + (CGFloat)appCpuUsage { task_info_data_t tinfo; mach_msg_type_number_t task_info_count = TASK_INFO_MAX; /// THREAD_BASIC_INFO ，使用这个类型会返回线程的基本信息，定义在 thread_basic_info_t 结构体，包含了用户和系统的运行时间，运行状态和调度优先级 kern_return_t kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)tinfo, &amp;amp;task_info_count); if (kr != KERN_SUCCESS) { return -1; } thread_array_t thread_list; mach_msg_type_number_t thread_count; thread_info_data_t thinfo; mach_msg_type_number_t thread_info_count; thread_basic_info_t basic_info_th; // mach_task_self()，表示获取当前的 Mach task kr = task_threads(mach_task_self(), &amp;amp;thread_list, &amp;amp;thread_count); if (kr != KERN_SUCCESS) { return -1; } long total_time = 0; long total_userTime = 0; CGFloat total_cpu = 0; int j; // for each thread for (j = 0; j &amp;lt; (int)thread_count; j++) { thread_info_count = THREAD_INFO_MAX; kr = thread_info(thread_list[j], THREAD_BASIC_INFO, (thread_info_t)thinfo, &amp;amp;thread_info_count); if (kr != KERN_SUCCESS) { return -1; } basic_info_th = (thread_basic_info_t)thinfo; if (!(basic_info_th-&amp;gt;flags &amp;amp; TH_FLAGS_IDLE)) { total_time = total_time + basic_info_th-&amp;gt;user_time.seconds + basic_info_th-&amp;gt;system_time.seconds; total_userTime = total_userTime + basic_info_th-&amp;gt;user_time.microseconds + basic_info_th-&amp;gt;system_time.microseconds; total_cpu = total_cpu + basic_info_th-&amp;gt;cpu_usage / (float)TH_USAGE_SCALE * kMaxPercent; } } /// 防止出现内存泄漏必须调用它 kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t)); assert(kr == KERN_SUCCESS); return total_cpu; } CPU 核数 + (NSUInteger)cpuNumber { return [NSProcessInfo processInfo].activeProcessorCount; } CPU 频率 CPU 频率，就是 CPU 的时钟频率， 是 CPU 运算时的工作的频率（1秒内发生的同步脉冲数）的简称。单位是 Hz，它决定移动设备的运行速度。 在 iOS 中与 CPU 频率相关的性能指标有三个：CPU 频率，CPU 最大频率 和 CPU 最小频率。 + (NSUInteger)getSysInfo:(uint)typeSpecifier { size_t size = sizeof(int); int results; int mib[2] = {CTL_HW, typeSpecifier}; sysctl(mib, 2, &amp;amp;results, &amp;amp;size, NULL, 0); return (NSUInteger)results; } + (NSUInteger)getCpuFrequency { return [self getSysInfo:HW_CPU_FREQ]; } RAM(Random Access Memory) 物理内存（RAM）与 CPU 一样都是系统中最稀少的资源，也是最有可能产生竞争的资源，应用内存与性能直接相关 - 通常是以牺牲别的应用为代价。 不像 PC 端，iOS 没有交换空间作为备选资源，这就使得内存资源尤为重要。事实上，在 iOS 中就有 Jetsam 机制负责处理系统低 RAM 事件，Jetsam 是一种类似 Linux 的 Out-Of-Memory(Killer) 的机制。 App使用的内存 mach_task_basic_info 结构体存储了 Mach task 的内存使用信息，其中 resident_size 就是应用使用的物理内存大小，virtual_size 是虚拟内存大小。 #define MACH_TASK_BASIC_INFO 20 /* always 64-bit basic info */ struct mach_task_basic_info { mach_vm_size_t virtual_size; /* virtual memory size (bytes) */ mach_vm_size_t resident_size; /* resident memory size (bytes) */ mach_vm_size_t resident_size_max; /* maximum resident memory size (bytes) */ time_value_t user_time; /* total user run time for terminated threads */ time_value_t system_time; /* total system run time for terminated threads */ policy_t policy; /* default policy for new threads */ integer_t suspend_count; /* suspend count for task */ }; task_info API 根据指定的 flavor 类型返回 target_task 的信息。 kern_return_t task_info ( task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt ); 获取APP内存使用量 /** 获取APP内存使用量 @return byte */ + (unsigned long long)getAppRAMUsage { struct mach_task_basic_info info; mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT; kern_return_t kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&amp;amp;info, &amp;amp;count); if (kr != KERN_SUCCESS) { return 0; } return info.resident_size; } 获取系统内存总量 /** 获取系统内存总量 @return byte */ + (unsigned long long)getSystemRAMTotal { return [NSProcessInfo processInfo].physicalMemory; } 获取当前设备的内存使用情况 + (CGFloat)getUsedMemory { size_t length = 0; int mib[6] = {0}; int pagesize = 0; mib[0] = CTL_HW; mib[1] = HW_PAGESIZE; length = sizeof(pagesize); if (sysctl(mib, 2, &amp;amp;pagesize, &amp;amp;length, NULL, 0) &amp;lt; 0) { return 0; } mach_msg_type_number_t count = HOST_VM_INFO_COUNT; vm_statistics_data_t vmstat; if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;amp;vmstat, &amp;amp;count) != KERN_SUCCESS) { return 0; } int wireMem = vmstat.wire_count * pagesize; int activeMem = vmstat.active_count * pagesize; return wireMem + activeMem; }</summary></entry><entry><title type="html">IM消息总结</title><link href="http://localhost:4000/IM%E6%B6%88%E6%81%AF%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="IM消息总结" /><published>2020-10-20T00:00:00+08:00</published><updated>2020-10-20T00:00:00+08:00</updated><id>http://localhost:4000/IM%E6%B6%88%E6%81%AF%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/IM%E6%B6%88%E6%81%AF%E6%80%BB%E7%BB%93/">&lt;h3 id=&quot;离线消息&quot;&gt;离线消息&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  客户端登录时，服务端不推送全量离线消息，只推送离线消息计数器(数量)， 客户端显示在未读小红点
2. 客户端拿到离线消息， 遍历会话列表， 依次将未读消息累加，然后通知服务端清空离线消息计数器的增量数据
3. 客户端进入某会话时，上拉加载， 通过msgId分页查询离线消息
4. 客户端收到消息并保存在本地数据库后，向服务端发送ack, 然后服务端删除离线消息表的离线消息
 
 客户端和服务端消息衔接问题： (客户端本地存储历史消息， 那么客户端下拉加载新消息时，怎么判断是加载本地历史消息，还是请求服务器加载离线消息)
    1.  进入会话时， 根据未读消息计数器的最近的N条消息展示首页数据
    2.  下载加载时，请求服务端， 服务端按时间倒序返回上一页的消息，只到离线数据库中的数据全部返回给客户端
    3. 当离线消息库中没有离线消息时，返回给客户端一个标识， 客户端根据这个标识，在会话页面下一次加载时不请求服务器，直接请求本地数据库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;### 本地缓存
     客户端消息DB：(简易每个登录用户创建一个DB，切换用户时切换DB即可,  搭建一个完善IM体系 ， 每个DB至少对应3张表 )
        1.  一张用户存储聊天列表信息，这里假如它叫ChatList,  用户存储每个群或者单人会话的最后一条信息 。来消息时更新该表，并更新内存数据源中列表信息。或者每次来消息时更新内存数据源中列表信息 ，退出程序或者退出聊天列表页时进行数据库更新。后者避免了频繁操作数据库，效率更高
        2.   一张用户存储每个会话中的详细聊天记录 ，这里假如它叫MessageList。该表也是如此 ，要么接到消息立马更新数据库，要么先存入内存中，退出程序时进行数据库缓存
        3. 一张用于存储好友或者群列表信息 ，这里假如它叫myFriends ，每次登陆或者退出，或者修改好友备注，删除好友，设置星标好友等操作都需要更新该表&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 沙盒缓存：
    1. 当发送或者接收图片、语音、文件信息时，需要对信息内容进行沙盒缓存。
        沙盒缓存的目录分层 ，个人建议是在每个用户根据自己的userID在Cache中创建文件夹，该文件夹目录下创建每个会话的文件夹。
        这样做的好处在于 ， 当你需要删除聊天列表会话或者清空聊天记录 ，或者app进行内存清理时 ，便于找到该会话的所有缓存。大致的目录结构如下   ../Cache/userID(当前用户ID)/toUserID(某个群或者单聊对象)/...（图片，语音等缓存）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;发送消息&quot;&gt;发送消息&lt;/h3&gt;

&lt;h6 id=&quot;1-文本消息表情消息&quot;&gt;1. 文本消息/表情消息&lt;/h6&gt;
&lt;p&gt;直接调用咱们封装好的ChatManager的sendMessage方法即可 ， 发送消息时 ，需要存入或者更新ChatList和MessageList两张表。若是未连接或者发送超时 ，需要重新更新数据库存储的发送成功与否状态 ，同时更新内存数据源 ，刷新该条消息展示即可。&lt;/p&gt;

&lt;p&gt;若是表情消息 ，传输过程也是以文本的方式传输 ，比如一个大笑的表情 ，可以定义为[大笑] ，当然规则自己可以和安卓端web端协商，本地根据plist文件和表情包匹配进行图文混排展示即可&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 输入 内容
- 发送 
- 消息加入聊天数据源 
- 更新数据库 
- 展示到聊天会话中 
 - 调用TCP发送到服务器（若超时，更新聊天数据源，更新数据库 ，刷新聊天UI）
- 收到服务器成功回执(normalReceipt) 
- 修改数据源该条消息发送状态(isSend) 
- 更新数据库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;2-语音消息&quot;&gt;2. 语音消息&lt;/h6&gt;

&lt;p&gt;语音需要做相应的降噪 ，压缩等操作
发送语音大约有两种方式 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;先对该条语音进行本地缓存 ， 然后全部内容均通过TCP传输并携带该条语音的相关信息，例如时长，大小等信息，具体的你得测试一条压缩后的语音体积有多大，若是过大，则需要进行分割然后以消息的方法时发送。接收语音时也进行拼接&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对该条语音进行本地缓存 ， 语音内容使用http传输，传输到服务器生成相应的id ，获取该id再附带该条语音的相关信息 ，以TCP方式发送给对方，当对方收到该条消息时，先去下载该条信息，并根据该条语音的相关信息进行展示。同时发送或接收时，对chatinfo和chatlist表和内存数据源进行更新 ，超时或者失败再次更新&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 长按录制 
- 压缩转格式 
- 缓存到沙盒 
- 更新数据库
- 展示到聊天会话中，展示转圈发送中状态 
- 调用http分段式上传(若失败，刷新UI展示) 
- 调用TCP发送该语音消息相关信息（若超时，刷新聊天UI）
- 收到服务器成功回执 
- 修改数据源该条消息发送状态(isSend) 
- 修改数据源该条消息发送状态(isSend)
- 更新数据库
- 刷新聊天会话中该条消息UI
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;3-图片消息&quot;&gt;3. 图片消息&lt;/h6&gt;
&lt;p&gt;图片应当分成两种大小 ， 一种是压缩得非常小的状态，一种是图片本身的大小状态。 聊天页面展示的 ，仅仅是小图 ，只有点击查看时才去加载大图。这样做的目的在于提高发送和接收的效率&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;先对该图片进行本地缓存 ， 然后全部内容均通过TCP传输 ，并携带该图片的相关信息 ，例如图片的大小 ，名字 ，宽高比等信息 。同样如果过大也需要进行分割传输。同时发送或接收时，对chatinfo和chatlist表和内存数据源进行更新 ，超时或者失败再次更新&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先对该图片进行本地缓存 ， 然后通过http传输到服务器 ，成功后发送TCP消息 ，并携带相关消息 。接收方根据你该条图片信息进行UI布局。同时发送或接收时，对chatinfo和chatlist表和内存数据源进行更新 ，超时或者失败再次更新&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;打开相册选择图片 
获取图片相关信息，大小，名称等，根据用户是否选择原图，考虑是否压缩 
缓存到沙盒 
更新数据库 
展示到聊天会话中，根据上传显示进度 
http分段式上传(若失败，更新聊天数据,更新数据库,刷新聊天UI) 
调用TCP发送该图片消息相关信息（若超时，更新聊天数据源，更新数据库,刷新聊天UI）
收到服务器成功回执 
修改数据源该条消息发送状态(isSend) 
更新数据库 
刷新聊天会话中该条消息UI

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;4-视频消息&quot;&gt;4. 视频消息&lt;/h6&gt;

&lt;p&gt;建议是走http上传比较好 ，因为内容一般偏大 。TCP部分仅需要传输该视频封面以及相关信息比如时长，下载地址等相关信息即可。接收方可以通过视频大小判断，如果是小视频可以接收到后默认自动下载，自动播放 ，大的视频则只展示封面，只有当用户手动点击时才去加载。具体的还是需要根据项目本身的设计而定&lt;/p&gt;

&lt;h6 id=&quot;5-撤回消息&quot;&gt;5. 撤回消息&lt;/h6&gt;

&lt;p&gt;撤回消息也是消息内容的一种类型 。&lt;/p&gt;

&lt;p&gt;例如 A给B发送了一条消息 “你好” ，服务端会对该条消息生成一个messageID ，接收方收到该条消息的messageID和发送方的该条消息messageID一致。&lt;/p&gt;

&lt;p&gt;如果发送端需要撤回该条消息 ，仅仅需要拿到该条消息messageID ，设置一下消息类型 ，发送给对方&lt;/p&gt;

&lt;p&gt;当收到撤回消息的成功回执(repealReceipt)时，移除该会话的内存数据源和更新chatinfo和chatlist表 ，&lt;/p&gt;

&lt;p&gt;并加载提示类型的cell进行展示例如“你撤回了一条消息”即可。接收方收到撤回消息时 ，同样移除内存数据源 ，并对数据库进行更新 ，再加载提示类型的cell例如“张三撤回了一条消息”即可&lt;/p&gt;

&lt;h3 id=&quot;删除消息&quot;&gt;删除消息&lt;/h3&gt;

&lt;p&gt;消息删除大概分为删除该条消息 ，删除该会话 ，清空聊天记录几种&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;删除该条消息仅仅需要移除本地数据源的消息模型 ，更新chatlist和chatinfo表即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除该会话需要移除chatlist和chatinfo该会话对应的列 ，并根据当前登录用户的userID和该会话的toUserID或者groupID移除沙盒中的缓存。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;清空聊天记录，需要更新chatlist表最后一条消息内容 ，删除chatinfo表，并删除该会话的沙盒缓存.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;

&lt;h5 id=&quot;如果服务器推送消息客户端没有消息回执可能存在丢消息&quot;&gt;如果服务器推送消息，客户端没有消息回执可能存在丢消息&lt;/h5&gt;

&lt;p&gt;原因： 服务器对客户端的网络判断不准确。尽管客户端已经和服务端建立了心跳验证 ， 但是心跳始终是有间隔的，且TCP的连接中断也是有延迟的。例如，在此时我向服务器发送了一次心跳，然后网络失去了连接，或者网络信号不好。服务器接收到了该心跳 ，服务器认为客户端是处于连接状态的，向我推送了某个人向我发送的消息 ，然而此时我却不能收到消息，所以出现了消息丢失的情况。&lt;/p&gt;

&lt;p&gt;解决办法 ：客户端向服务端发送消息，服务端会给客户端返回一个回执，告知该条消息已经发送成功。所以，客户端有必要在收到消息时，也向服务端发送一个回执，告知服务端成功收到了该条消息。而客户端，默认收到的所有消息都是离线的，只有收到客户端的接收消息的成功回执后，才会移除掉该离线消息缓存，否则将会把该条消息以离线消息方式同步推送。离线消息后面会做解释。此时的双向回执，可以把消息丢失概率降到非常低 ,基本上算是模拟了一个消息数据传输的三次握手。&lt;/p&gt;

&lt;h5 id=&quot;消息乱序&quot;&gt;消息乱序&lt;/h5&gt;

&lt;p&gt;原因： 客户端发送消息，该消息会默认赋值当前时间戳 ，收到安卓端或者web端发来的消息时，该时间戳是安卓和web端获取，这样就可能会出现时间戳的误差情况， 当前聊天展示顺序并没有什么问题，因为展示是收到一条展示一条。但是当退出页面重新进入时，如果拉取数据库是根据时间戳的降序拉取 ，那么就很容易出现混乱。&lt;/p&gt;

&lt;p&gt;解决办法 ： 表结构设置自增ID ，消息的顺序展示以入库顺序为准 ，拉取数据库获取消息记录时，根据自增ID降序拉取 。这样就解决了乱序问题 ，至少保证了，展示的消息顺序和我聊天时的一样。尽管时间戳可能并不一样是按照严谨的降序排列的。&lt;/p&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">离线消息 1. 客户端登录时，服务端不推送全量离线消息，只推送离线消息计数器(数量)， 客户端显示在未读小红点 2. 客户端拿到离线消息， 遍历会话列表， 依次将未读消息累加，然后通知服务端清空离线消息计数器的增量数据 3. 客户端进入某会话时，上拉加载， 通过msgId分页查询离线消息 4. 客户端收到消息并保存在本地数据库后，向服务端发送ack, 然后服务端删除离线消息表的离线消息 客户端和服务端消息衔接问题： (客户端本地存储历史消息， 那么客户端下拉加载新消息时，怎么判断是加载本地历史消息，还是请求服务器加载离线消息) 1. 进入会话时， 根据未读消息计数器的最近的N条消息展示首页数据 2. 下载加载时，请求服务端， 服务端按时间倒序返回上一页的消息，只到离线数据库中的数据全部返回给客户端 3. 当离线消息库中没有离线消息时，返回给客户端一个标识， 客户端根据这个标识，在会话页面下一次加载时不请求服务器，直接请求本地数据库 ### 本地缓存 客户端消息DB：(简易每个登录用户创建一个DB，切换用户时切换DB即可, 搭建一个完善IM体系 ， 每个DB至少对应3张表 ) 1. 一张用户存储聊天列表信息，这里假如它叫ChatList, 用户存储每个群或者单人会话的最后一条信息 。来消息时更新该表，并更新内存数据源中列表信息。或者每次来消息时更新内存数据源中列表信息 ，退出程序或者退出聊天列表页时进行数据库更新。后者避免了频繁操作数据库，效率更高 2. 一张用户存储每个会话中的详细聊天记录 ，这里假如它叫MessageList。该表也是如此 ，要么接到消息立马更新数据库，要么先存入内存中，退出程序时进行数据库缓存 3. 一张用于存储好友或者群列表信息 ，这里假如它叫myFriends ，每次登陆或者退出，或者修改好友备注，删除好友，设置星标好友等操作都需要更新该表 沙盒缓存： 1. 当发送或者接收图片、语音、文件信息时，需要对信息内容进行沙盒缓存。 沙盒缓存的目录分层 ，个人建议是在每个用户根据自己的userID在Cache中创建文件夹，该文件夹目录下创建每个会话的文件夹。 这样做的好处在于 ， 当你需要删除聊天列表会话或者清空聊天记录 ，或者app进行内存清理时 ，便于找到该会话的所有缓存。大致的目录结构如下 ../Cache/userID(当前用户ID)/toUserID(某个群或者单聊对象)/...（图片，语音等缓存） 发送消息 1. 文本消息/表情消息 直接调用咱们封装好的ChatManager的sendMessage方法即可 ， 发送消息时 ，需要存入或者更新ChatList和MessageList两张表。若是未连接或者发送超时 ，需要重新更新数据库存储的发送成功与否状态 ，同时更新内存数据源 ，刷新该条消息展示即可。 若是表情消息 ，传输过程也是以文本的方式传输 ，比如一个大笑的表情 ，可以定义为[大笑] ，当然规则自己可以和安卓端web端协商，本地根据plist文件和表情包匹配进行图文混排展示即可 - 输入 内容 - 发送 - 消息加入聊天数据源 - 更新数据库 - 展示到聊天会话中 - 调用TCP发送到服务器（若超时，更新聊天数据源，更新数据库 ，刷新聊天UI） - 收到服务器成功回执(normalReceipt) - 修改数据源该条消息发送状态(isSend) - 更新数据库 2. 语音消息 语音需要做相应的降噪 ，压缩等操作 发送语音大约有两种方式 : 先对该条语音进行本地缓存 ， 然后全部内容均通过TCP传输并携带该条语音的相关信息，例如时长，大小等信息，具体的你得测试一条压缩后的语音体积有多大，若是过大，则需要进行分割然后以消息的方法时发送。接收语音时也进行拼接 对该条语音进行本地缓存 ， 语音内容使用http传输，传输到服务器生成相应的id ，获取该id再附带该条语音的相关信息 ，以TCP方式发送给对方，当对方收到该条消息时，先去下载该条信息，并根据该条语音的相关信息进行展示。同时发送或接收时，对chatinfo和chatlist表和内存数据源进行更新 ，超时或者失败再次更新 - 长按录制 - 压缩转格式 - 缓存到沙盒 - 更新数据库 - 展示到聊天会话中，展示转圈发送中状态 - 调用http分段式上传(若失败，刷新UI展示) - 调用TCP发送该语音消息相关信息（若超时，刷新聊天UI） - 收到服务器成功回执 - 修改数据源该条消息发送状态(isSend) - 修改数据源该条消息发送状态(isSend) - 更新数据库 - 刷新聊天会话中该条消息UI 3. 图片消息 图片应当分成两种大小 ， 一种是压缩得非常小的状态，一种是图片本身的大小状态。 聊天页面展示的 ，仅仅是小图 ，只有点击查看时才去加载大图。这样做的目的在于提高发送和接收的效率 先对该图片进行本地缓存 ， 然后全部内容均通过TCP传输 ，并携带该图片的相关信息 ，例如图片的大小 ，名字 ，宽高比等信息 。同样如果过大也需要进行分割传输。同时发送或接收时，对chatinfo和chatlist表和内存数据源进行更新 ，超时或者失败再次更新 先对该图片进行本地缓存 ， 然后通过http传输到服务器 ，成功后发送TCP消息 ，并携带相关消息 。接收方根据你该条图片信息进行UI布局。同时发送或接收时，对chatinfo和chatlist表和内存数据源进行更新 ，超时或者失败再次更新 打开相册选择图片 获取图片相关信息，大小，名称等，根据用户是否选择原图，考虑是否压缩 缓存到沙盒 更新数据库 展示到聊天会话中，根据上传显示进度 http分段式上传(若失败，更新聊天数据,更新数据库,刷新聊天UI) 调用TCP发送该图片消息相关信息（若超时，更新聊天数据源，更新数据库,刷新聊天UI） 收到服务器成功回执 修改数据源该条消息发送状态(isSend) 更新数据库 刷新聊天会话中该条消息UI 4. 视频消息 建议是走http上传比较好 ，因为内容一般偏大 。TCP部分仅需要传输该视频封面以及相关信息比如时长，下载地址等相关信息即可。接收方可以通过视频大小判断，如果是小视频可以接收到后默认自动下载，自动播放 ，大的视频则只展示封面，只有当用户手动点击时才去加载。具体的还是需要根据项目本身的设计而定 5. 撤回消息 撤回消息也是消息内容的一种类型 。 例如 A给B发送了一条消息 “你好” ，服务端会对该条消息生成一个messageID ，接收方收到该条消息的messageID和发送方的该条消息messageID一致。 如果发送端需要撤回该条消息 ，仅仅需要拿到该条消息messageID ，设置一下消息类型 ，发送给对方 当收到撤回消息的成功回执(repealReceipt)时，移除该会话的内存数据源和更新chatinfo和chatlist表 ， 并加载提示类型的cell进行展示例如“你撤回了一条消息”即可。接收方收到撤回消息时 ，同样移除内存数据源 ，并对数据库进行更新 ，再加载提示类型的cell例如“张三撤回了一条消息”即可 删除消息 消息删除大概分为删除该条消息 ，删除该会话 ，清空聊天记录几种 删除该条消息仅仅需要移除本地数据源的消息模型 ，更新chatlist和chatinfo表即可。 删除该会话需要移除chatlist和chatinfo该会话对应的列 ，并根据当前登录用户的userID和该会话的toUserID或者groupID移除沙盒中的缓存。 清空聊天记录，需要更新chatlist表最后一条消息内容 ，删除chatinfo表，并删除该会话的沙盒缓存. 注意事项 如果服务器推送消息，客户端没有消息回执可能存在丢消息 原因： 服务器对客户端的网络判断不准确。尽管客户端已经和服务端建立了心跳验证 ， 但是心跳始终是有间隔的，且TCP的连接中断也是有延迟的。例如，在此时我向服务器发送了一次心跳，然后网络失去了连接，或者网络信号不好。服务器接收到了该心跳 ，服务器认为客户端是处于连接状态的，向我推送了某个人向我发送的消息 ，然而此时我却不能收到消息，所以出现了消息丢失的情况。 解决办法 ：客户端向服务端发送消息，服务端会给客户端返回一个回执，告知该条消息已经发送成功。所以，客户端有必要在收到消息时，也向服务端发送一个回执，告知服务端成功收到了该条消息。而客户端，默认收到的所有消息都是离线的，只有收到客户端的接收消息的成功回执后，才会移除掉该离线消息缓存，否则将会把该条消息以离线消息方式同步推送。离线消息后面会做解释。此时的双向回执，可以把消息丢失概率降到非常低 ,基本上算是模拟了一个消息数据传输的三次握手。 消息乱序 原因： 客户端发送消息，该消息会默认赋值当前时间戳 ，收到安卓端或者web端发来的消息时，该时间戳是安卓和web端获取，这样就可能会出现时间戳的误差情况， 当前聊天展示顺序并没有什么问题，因为展示是收到一条展示一条。但是当退出页面重新进入时，如果拉取数据库是根据时间戳的降序拉取 ，那么就很容易出现混乱。 解决办法 ： 表结构设置自增ID ，消息的顺序展示以入库顺序为准 ，拉取数据库获取消息记录时，根据自增ID降序拉取 。这样就解决了乱序问题 ，至少保证了，展示的消息顺序和我聊天时的一样。尽管时间戳可能并不一样是按照严谨的降序排列的。</summary></entry><entry><title type="html">金融财报思维导图</title><link href="http://localhost:4000/%E9%87%91%E8%9E%8D%E8%B4%A2%E6%8A%A5%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" rel="alternate" type="text/html" title="金融财报思维导图" /><published>2020-08-20T00:00:00+08:00</published><updated>2020-08-20T00:00:00+08:00</updated><id>http://localhost:4000/%E9%87%91%E8%9E%8D%E8%B4%A2%E6%8A%A5%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE</id><content type="html" xml:base="http://localhost:4000/%E9%87%91%E8%9E%8D%E8%B4%A2%E6%8A%A5%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">&lt;h3 id=&quot;金融读书笔记&quot;&gt;金融读书笔记&lt;/h3&gt;

&lt;p&gt;利润表总结
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad3aad16222b45638fbea57d7d923bf4~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;利润表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;速读利润表
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea0c8e20fc7e4ec68e4721dde4aa48ab~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;速读利润表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;投资相关资产
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/417994ec6c2c44fe8f8478b0af129bed~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;投资相关资产&quot; /&gt;&lt;/p&gt;

&lt;p&gt;操纵手法
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ba33936f35a400bab68917917ca673d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;操纵手法&quot; /&gt;&lt;/p&gt;

&lt;p&gt;财报被操纵的痕迹
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dba832c3aac4079acc130d4fa33433f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;操纵痕迹&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现金流肖像
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5012dd36eda5485cbafd8aeb843944ab~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;现金流肖像&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现金流速读
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd26efad9e4640aa9bcfbd70b322ce29~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;现金流速读&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现金流量表
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cc9a9e4b4d94045b8f107636bf1e2c4~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;现金流量表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;生产相关资产
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b73c50ee7b645378edfde6510f259e6~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;生产相关资产&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经营相关资产
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a09362842c9439a9fe9c922096a6873~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;经营相关资产&quot; /&gt;&lt;/p&gt;

&lt;p&gt;货币资金
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d99996532d4844eba652ca2345e7cf49~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;货币资金&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="金融" /><summary type="html">金融读书笔记 利润表总结 速读利润表 投资相关资产 操纵手法 财报被操纵的痕迹 现金流肖像 现金流速读 现金流量表 生产相关资产 经营相关资产 货币资金</summary></entry><entry><title type="html">APM总结</title><link href="http://localhost:4000/iOS%E7%94%BB%E4%B8%AD%E7%94%BB%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="APM总结" /><published>2020-06-20T00:00:00+08:00</published><updated>2020-06-20T00:00:00+08:00</updated><id>http://localhost:4000/iOS%E7%94%BB%E4%B8%AD%E7%94%BB%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/iOS%E7%94%BB%E4%B8%AD%E7%94%BB%E6%80%BB%E7%BB%93/">&lt;h2 id=&quot;ios画中画总结&quot;&gt;iOS画中画总结&lt;/h2&gt;
&lt;p&gt;之前在做iOS的音视频播放的时候，iOS小窗播放音视频退到后台后启用画中画功能，遇到一些坑，记录一下，做一些总结&lt;/p&gt;

&lt;p&gt;通过分析B站等一些视频播放APP发现，B站播放视频开启小窗后，播放在APP内变成小窗播放，该小窗是开发者自定义的view，退到后台后，开启了画中画(交由系统接管)，并实现无缝的进度衔接，从画中画回到APP，画中画消失，切换回自定义的播放View, 并同步回系统画中画的进度&lt;/p&gt;

&lt;h3 id=&quot;启用画中画&quot;&gt;启用画中画&lt;/h3&gt;
&lt;p&gt;在Xcode的能力中勾选开启画中画
&lt;img src=&quot;media/16685090834891.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;实现画中画&quot;&gt;实现画中画&lt;/h3&gt;
&lt;p&gt;iOS系统提供了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVPictureInPictureController&lt;/code&gt;API给开发者，可以实现画中画&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建画中画属性，实现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;AVPictureInPictureControllerDelegate&amp;gt;&lt;/code&gt;代理
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property (nonatomic, strong) AVPictureInPictureController *pipVC;
@property (nonatomic, strong) AVPlayerLayer *playerLayer;
@property (nonatomic, strong) AVPlayer *player;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;判断是否支持画中画功能并开启权限
``` 
if (!_player) {
  self.player = [AVPlayer playerWithURL:[NSURL URLWithString: self.playerShowView.currentPlayUrl]];
  self.playerLayer = [AVPlayerLayer playerLayerWithPlayer:self.player];
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;if ([AVPictureInPictureController isPictureInPictureSupported]) {
    @try {
        NSError *error = nil;
        [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&amp;amp;error];
        [[AVAudioSession sharedInstance] setActive:YES error:&amp;amp;error];&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if (error) {
        NSLog(@&quot;请求后台播放权限失败: %@&quot;,error);
    }
    
} @catch (NSException *exception) {
    NSLog(@&quot;AVAudioSession发生错误&quot;);
}
self.pipVC = [[AVPictureInPictureController alloc] initWithPlayerLayer:self.playerLayer];
self.pipVC.delegate = self; } ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;实现画中画代理
```
// 关闭画中画且恢复播放界面&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(void)pictureInPictureController:(AVPictureInPictureController *)pictureInPictureController restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:(void (^)(BOOL restored))completionHandler {&lt;/p&gt;

    &lt;p&gt;completionHandler(true);&lt;/p&gt;

    &lt;p&gt;CGFloat currentTime = self.player.currentTime.value / self.player.currentTime.timescale;
  NSLog(@”画中画恢复了: %f”, currentTime);
}
```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;画中画遇到的一些坑&quot;&gt;画中画遇到的一些坑&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;不能把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;playerLayer&lt;/code&gt;加在window的layer上会报错，加在view的layer上不会报错&lt;/li&gt;
  &lt;li&gt;画中画的宽度或者尺寸设置为屏幕的尺寸后，APP退到后台，会自动开启画中画&lt;/li&gt;
  &lt;li&gt;开启画中画的时候需要判断状态，刚初始化的AVPictureInPictureController直接开启是不可用的&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">iOS画中画总结 之前在做iOS的音视频播放的时候，iOS小窗播放音视频退到后台后启用画中画功能，遇到一些坑，记录一下，做一些总结 通过分析B站等一些视频播放APP发现，B站播放视频开启小窗后，播放在APP内变成小窗播放，该小窗是开发者自定义的view，退到后台后，开启了画中画(交由系统接管)，并实现无缝的进度衔接，从画中画回到APP，画中画消失，切换回自定义的播放View, 并同步回系统画中画的进度 启用画中画 在Xcode的能力中勾选开启画中画 实现画中画 iOS系统提供了AVPictureInPictureControllerAPI给开发者，可以实现画中画 创建画中画属性，实现&amp;lt;AVPictureInPictureControllerDelegate&amp;gt;代理 @property (nonatomic, strong) AVPictureInPictureController *pipVC; @property (nonatomic, strong) AVPlayerLayer *playerLayer; @property (nonatomic, strong) AVPlayer *player; 判断是否支持画中画功能并开启权限 ``` if (!_player) { self.player = [AVPlayer playerWithURL:[NSURL URLWithString: self.playerShowView.currentPlayUrl]]; self.playerLayer = [AVPlayerLayer playerLayerWithPlayer:self.player]; } if ([AVPictureInPictureController isPictureInPictureSupported]) { @try { NSError *error = nil; [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&amp;amp;error]; [[AVAudioSession sharedInstance] setActive:YES error:&amp;amp;error]; if (error) { NSLog(@&quot;请求后台播放权限失败: %@&quot;,error); } } @catch (NSException *exception) { NSLog(@&quot;AVAudioSession发生错误&quot;); } self.pipVC = [[AVPictureInPictureController alloc] initWithPlayerLayer:self.playerLayer]; self.pipVC.delegate = self; } ``` 实现画中画代理 ``` // 关闭画中画且恢复播放界面 (void)pictureInPictureController:(AVPictureInPictureController *)pictureInPictureController restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:(void (^)(BOOL restored))completionHandler { completionHandler(true); CGFloat currentTime = self.player.currentTime.value / self.player.currentTime.timescale; NSLog(@”画中画恢复了: %f”, currentTime); } ``` 画中画遇到的一些坑 不能把playerLayer加在window的layer上会报错，加在view的layer上不会报错 画中画的宽度或者尺寸设置为屏幕的尺寸后，APP退到后台，会自动开启画中画 开启画中画的时候需要判断状态，刚初始化的AVPictureInPictureController直接开启是不可用的</summary></entry><entry><title type="html">APM总结</title><link href="http://localhost:4000/APM%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="APM总结" /><published>2020-06-20T00:00:00+08:00</published><updated>2020-06-20T00:00:00+08:00</updated><id>http://localhost:4000/APM%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/APM%E6%80%BB%E7%BB%93/">&lt;h5 id=&quot;apm监控卡顿并上报有两种方案&quot;&gt;APM监控卡顿并上报有两种方案：&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;监听Runloop状态回调， 子线程ping主线程
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if (currentMode-&amp;gt;_observerMask &amp;amp; kCFRunLoopEntry )
        // 通知 Observers: RunLoop 即将进入 loop
        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    // 进入loop
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开启do while 循环保活线程，通知Observers, Runloop触发timer回调，然后执行被加入的Block
```
  if (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeTimers)
     //  通知 Observers: RunLoop 即将触发 Timer 回调
     __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);&lt;/p&gt;

    &lt;p&gt;if (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeSources)
     //  通知 Observers: RunLoop 即将触发 Source 回调
     __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);
 // 执行被加入的block
 __CFRunLoopDoBlocks(rl, rlm);&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3. runloop触发source0的回调，如果source1是ready状态，会跳转到handle_msg去处理消息, 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (MACH_PORT_NULL != dispatchPort &amp;amp;&amp;amp; !didDispatchPortLastTime) {
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
    msg = (mach_msg_header_t *)msg_buffer;
    
    if (__CFRunLoopServiceMachPort(dispatchPort, &amp;amp;msg, sizeof(msg_buffer), &amp;amp;livePort, 0, &amp;amp;voucherState, NULL)) {
        goto handle_msg;
    }
#elif DEPLOYMENT_TARGET_WINDOWS
    if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;amp;dispatchPort, 0, 0, &amp;amp;livePort, NULL)) {
        goto handle_msg;
    }
#endif
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4. 回调触发后，通知Observer进入休眠状态
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&amp;gt;termTSR);
 // 通知 Observers: RunLoop 的线程即将进入休眠(sleep)
 if (!poll &amp;amp;&amp;amp; (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);
     __CFRunLoopSetSleeping(rl);&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5. 休眠后，等待mach_port消息，以便再次唤醒
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do {
    if (kCFUseCollectableAllocator) {
        // objc_clear_stack(0);
        // &amp;lt;rdar://problem/16393959&amp;gt;
        memset(msg_buffer, 0, sizeof(msg_buffer));
    }
    msg = (mach_msg_header_t *)msg_buffer;
    
    __CFRunLoopServiceMachPort(waitSet, &amp;amp;msg, sizeof(msg_buffer), &amp;amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;amp;voucherState, &amp;amp;voucherCopy);
    
    if (modeQueuePort != MACH_PORT_NULL &amp;amp;&amp;amp; livePort == modeQueuePort) {
        // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.
        while (_dispatch_runloop_root_queue_perform_4CF(rlm-&amp;gt;_queue));
        if (rlm-&amp;gt;_timerFired) {
            // Leave livePort as the queue port, and service timers below
            rlm-&amp;gt;_timerFired = false;
            break;
        } else {
            if (msg &amp;amp;&amp;amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);
        }
    } else {
        // Go ahead and leave the inner loop.
        break;
    }
} while (1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
6. 唤醒时通知Observer， Runloop的线程刚刚被唤醒了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 通知 Observers: RunLoop 的线程刚刚被唤醒了
if (!poll &amp;amp;&amp;amp; (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);
    // 处理消息
    handle_msg:;
    __CFRunLoopSetIgnoreWakeUps(rl);  ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Runloop唤醒后，处理唤醒时收到的消息&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;///如果是Timer处理回调
///如果是dispatch，处理block
///如果是source1， 处理事件

 #if USE_MK_TIMER_TOO
         // 如果一个 Timer 到时间了，触发这个Timer的回调
         else if (rlm-&amp;gt;_timerPort != MACH_PORT_NULL &amp;amp;&amp;amp; livePort == rlm-&amp;gt;_timerPort) {
             CFRUNLOOP_WAKEUP_FOR_TIMER();
             // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.
             // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754
             if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
                 // Re-arm the next timer
                 __CFArmNextTimerInMode(rlm, rl);
             }
         }
 #endif
         //  如果有dispatch到main_queue的block，执行block
         else if (livePort == dispatchPort) {
             CFRUNLOOP_WAKEUP_FOR_DISPATCH();
             __CFRunLoopModeUnlock(rlm);
             __CFRunLoopUnlock(rl);
             _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);
 #if DEPLOYMENT_TARGET_WINDOWS
             void *msg = 0;
 #endif
             __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
             _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);
             __CFRunLoopLock(rl);
             __CFRunLoopModeLock(rlm);
             sourceHandledThisLoop = true;
             didDispatchPortLastTime = true;
         }
         // 如果一个 Source1 (基于port) 发出事件了，处理这个事件
         else {
             CFRUNLOOP_WAKEUP_FOR_SOURCE();
             
             // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.
             voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);

             CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);
             if (rls) {
 #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
         mach_msg_header_t *reply = NULL;
         sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&amp;gt;msgh_size, &amp;amp;reply) || sourceHandledThisLoop;
         if (NULL != reply) {
             (void)mach_msg(reply, MACH_SEND_MSG, reply-&amp;gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
             CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);
         }
 #elif DEPLOYMENT_TARGET_WINDOWS
                 sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;
 #endif

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;根据当前runloop状态判断是否需要进入下一个loop, 当被外部强制停止或者loop超时，就不继续下一个loop,  否则进入下一个loop&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
    if (sourceHandledThisLoop &amp;amp;&amp;amp; stopAfterHandle) {
        // 进入loop时参数说处理完事件就返回
        retVal = kCFRunLoopRunHandledSource;
        } else if (timeout_context-&amp;gt;termTSR &amp;lt; mach_absolute_time()) {
            // 超出传入参数标记的超时时间了
            retVal = kCFRunLoopRunTimedOut;
    } else if (__CFRunLoopIsStopped(rl)) {
            __CFRunLoopUnsetStopped(rl);
        // 被外部调用者强制停止了
        retVal = kCFRunLoopRunStopped;
    } else if (rlm-&amp;gt;_stopped) {
        rlm-&amp;gt;_stopped = false;
        retVal = kCFRunLoopRunStopped;
    } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {
        // source/timer一个都没有
        retVal = kCFRunLoopRunFinished;
    }

 */

/// Source1是runloop用来处理Mach port传来的系统的事件的，  Source0是用来处理用户事件的
/// 检测runloop，一旦发现在进入睡眠前的KCFRunLoopBeforeSources到唤醒后 KCFRunLoopAfterWaiting的时间过长，说明Runloop卡顿了， 开启一个子线程，不断的去循环检测，如果在n次都超过了预定好的阈值， 认为是卡顿了， 然后进行dump当前的堆栈并上报

/**
 通过 long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)  方法判断是否阻塞主线程，Returns zero on success, or non-zero if the timeout occurred.  返回非0则代表超时阻塞了主线程
 */



//MARK: 子线程ping主线程监听的方式
///开启一个子线程，创建一个初始值为0的信号量， 一个bool标志位，将设置为NO的标志位的任务派发到主线程中去， 子线程休眠阈值到后判断是否被主线程成功，如果没成功认为是主线程卡顿
/*
 
 while (self.isCancelled == NO) {
 
     @autoreleasepool {
         __block BOOL isMainThreadNoRespond = YES;
         
         dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
         
         dispatch_async(dispatch_get_main_queue(), ^{
             isMainThreadNoRespond = NO;
             dispatch_semaphore_signal(semaphore);
         });
         
         [NSThread sleepForTimeInterval:self.threshold];
         
         if (isMainThreadNoRespond) {
             if (self.handlerBlock) {
                 self.handlerBlock(); // 外部在 block 内部 dump 堆栈（下面会讲），数据上报
             }
         }
         
         dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
     }
 }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;启动时间监控&quot;&gt;启动时间监控&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 . pre-main阶段影响因素
/**
 1. 动态库越多，启动越慢
 2. Objc类越好,  函数越多，启动越慢
 3. 可执行文件越大，启动越慢
 4. Objc的load方法越多，启动越慢
 */

/**
    struct thread_basic_info {
        time_value_t    user_time;      /* user run time（用户运行时长） */
        time_value_t    system_time;    /* system run time（系统运行时长） */
        integer_t       cpu_usage;      /* scaled cpu usage percentage（CPU使用率，上限1000） */
        policy_t        policy;         /* scheduling policy in effect（有效调度策略） */
        integer_t       run_state;      /* run state (运行状态，见下) */
        integer_t       flags;          /* various flags (各种各样的标记) */
        integer_t       suspend_count;  /* suspend count for thread（线程挂起次数） */
        integer_t       sleep_time;     /* number of seconds that thread
                                         *  has been sleeping（休眠时间） */
    };
 */

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OOM 超出了内存分配
/// 收到低内存警告不一定会 Crash，因为有6秒钟的系统判断时间，6秒内内存下降了则不会 crash。发生 OOM 也不一定会收到低内存警告
/**
 合理使用autoreleasepool, autoreleasepool对象是在Runloop结束时释放，在ARC下， 如果我们不断的申请内存， 我们需要手动的添加autoreleasepool， 避免短时间内内存猛涨发生OOM
 内存分配:  malloc用的是 malloc_zone_malloc,  calloc用的是malloc_zone_calloc
  在处理图片缩放时，ImageIO占用内存会比直接处理图片缩放小
 */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">APM监控卡顿并上报有两种方案： 监听Runloop状态回调， 子线程ping主线程 if (currentMode-&amp;gt;_observerMask &amp;amp; kCFRunLoopEntry ) // 通知 Observers: RunLoop 即将进入 loop __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); // 进入loop result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); 开启do while 循环保活线程，通知Observers, Runloop触发timer回调，然后执行被加入的Block ``` if (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeTimers) // 通知 Observers: RunLoop 即将触发 Timer 回调 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); if (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeSources) // 通知 Observers: RunLoop 即将触发 Source 回调 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); // 执行被加入的block __CFRunLoopDoBlocks(rl, rlm); 3. runloop触发source0的回调，如果source1是ready状态，会跳转到handle_msg去处理消息, 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息 if (MACH_PORT_NULL != dispatchPort &amp;amp;&amp;amp; !didDispatchPortLastTime) { #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI msg = (mach_msg_header_t *)msg_buffer; if (__CFRunLoopServiceMachPort(dispatchPort, &amp;amp;msg, sizeof(msg_buffer), &amp;amp;livePort, 0, &amp;amp;voucherState, NULL)) { goto handle_msg; } #elif DEPLOYMENT_TARGET_WINDOWS if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;amp;dispatchPort, 0, 0, &amp;amp;livePort, NULL)) { goto handle_msg; } #endif } 4. 回调触发后，通知Observer进入休眠状态 Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&amp;gt;termTSR); // 通知 Observers: RunLoop 的线程即将进入休眠(sleep) if (!poll &amp;amp;&amp;amp; (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); __CFRunLoopSetSleeping(rl); 5. 休眠后，等待mach_port消息，以便再次唤醒 do { if (kCFUseCollectableAllocator) { // objc_clear_stack(0); // &amp;lt;rdar://problem/16393959&amp;gt; memset(msg_buffer, 0, sizeof(msg_buffer)); } msg = (mach_msg_header_t *)msg_buffer; __CFRunLoopServiceMachPort(waitSet, &amp;amp;msg, sizeof(msg_buffer), &amp;amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;amp;voucherState, &amp;amp;voucherCopy); if (modeQueuePort != MACH_PORT_NULL &amp;amp;&amp;amp; livePort == modeQueuePort) { // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer. while (_dispatch_runloop_root_queue_perform_4CF(rlm-&amp;gt;_queue)); if (rlm-&amp;gt;_timerFired) { // Leave livePort as the queue port, and service timers below rlm-&amp;gt;_timerFired = false; break; } else { if (msg &amp;amp;&amp;amp; msg != (mach_msg_header_t *)msg_buffer) free(msg); } } else { // Go ahead and leave the inner loop. break; } } while (1); 6. 唤醒时通知Observer， Runloop的线程刚刚被唤醒了 // 通知 Observers: RunLoop 的线程刚刚被唤醒了 if (!poll &amp;amp;&amp;amp; (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); // 处理消息 handle_msg:; __CFRunLoopSetIgnoreWakeUps(rl); ``` Runloop唤醒后，处理唤醒时收到的消息 ///如果是Timer处理回调 ///如果是dispatch，处理block ///如果是source1， 处理事件 #if USE_MK_TIMER_TOO // 如果一个 Timer 到时间了，触发这个Timer的回调 else if (rlm-&amp;gt;_timerPort != MACH_PORT_NULL &amp;amp;&amp;amp; livePort == rlm-&amp;gt;_timerPort) { CFRUNLOOP_WAKEUP_FOR_TIMER(); // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled. // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754 if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) { // Re-arm the next timer __CFArmNextTimerInMode(rlm, rl); } } #endif // 如果有dispatch到main_queue的block，执行block else if (livePort == dispatchPort) { CFRUNLOOP_WAKEUP_FOR_DISPATCH(); __CFRunLoopModeUnlock(rlm); __CFRunLoopUnlock(rl); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL); #if DEPLOYMENT_TARGET_WINDOWS void *msg = 0; #endif __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL); __CFRunLoopLock(rl); __CFRunLoopModeLock(rlm); sourceHandledThisLoop = true; didDispatchPortLastTime = true; } // 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else { CFRUNLOOP_WAKEUP_FOR_SOURCE(); // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again. voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release); CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort); if (rls) { #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI mach_msg_header_t *reply = NULL; sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&amp;gt;msgh_size, &amp;amp;reply) || sourceHandledThisLoop; if (NULL != reply) { (void)mach_msg(reply, MACH_SEND_MSG, reply-&amp;gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL); CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply); } #elif DEPLOYMENT_TARGET_WINDOWS sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop; #endif 根据当前runloop状态判断是否需要进入下一个loop, 当被外部强制停止或者loop超时，就不继续下一个loop, 否则进入下一个loop /** if (sourceHandledThisLoop &amp;amp;&amp;amp; stopAfterHandle) { // 进入loop时参数说处理完事件就返回 retVal = kCFRunLoopRunHandledSource; } else if (timeout_context-&amp;gt;termTSR &amp;lt; mach_absolute_time()) { // 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; } else if (__CFRunLoopIsStopped(rl)) { __CFRunLoopUnsetStopped(rl); // 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; } else if (rlm-&amp;gt;_stopped) { rlm-&amp;gt;_stopped = false; retVal = kCFRunLoopRunStopped; } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) { // source/timer一个都没有 retVal = kCFRunLoopRunFinished; } */ /// Source1是runloop用来处理Mach port传来的系统的事件的， Source0是用来处理用户事件的 /// 检测runloop，一旦发现在进入睡眠前的KCFRunLoopBeforeSources到唤醒后 KCFRunLoopAfterWaiting的时间过长，说明Runloop卡顿了， 开启一个子线程，不断的去循环检测，如果在n次都超过了预定好的阈值， 认为是卡顿了， 然后进行dump当前的堆栈并上报 /** 通过 long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) 方法判断是否阻塞主线程，Returns zero on success, or non-zero if the timeout occurred. 返回非0则代表超时阻塞了主线程 */ //MARK: 子线程ping主线程监听的方式 ///开启一个子线程，创建一个初始值为0的信号量， 一个bool标志位，将设置为NO的标志位的任务派发到主线程中去， 子线程休眠阈值到后判断是否被主线程成功，如果没成功认为是主线程卡顿 /* while (self.isCancelled == NO) { @autoreleasepool { __block BOOL isMainThreadNoRespond = YES; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_async(dispatch_get_main_queue(), ^{ isMainThreadNoRespond = NO; dispatch_semaphore_signal(semaphore); }); [NSThread sleepForTimeInterval:self.threshold]; if (isMainThreadNoRespond) { if (self.handlerBlock) { self.handlerBlock(); // 外部在 block 内部 dump 堆栈（下面会讲），数据上报 } } dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); } } 启动时间监控 1 . pre-main阶段影响因素 /** 1. 动态库越多，启动越慢 2. Objc类越好, 函数越多，启动越慢 3. 可执行文件越大，启动越慢 4. Objc的load方法越多，启动越慢 */ /** struct thread_basic_info { time_value_t user_time; /* user run time（用户运行时长） */ time_value_t system_time; /* system run time（系统运行时长） */ integer_t cpu_usage; /* scaled cpu usage percentage（CPU使用率，上限1000） */ policy_t policy; /* scheduling policy in effect（有效调度策略） */ integer_t run_state; /* run state (运行状态，见下) */ integer_t flags; /* various flags (各种各样的标记) */ integer_t suspend_count; /* suspend count for thread（线程挂起次数） */ integer_t sleep_time; /* number of seconds that thread * has been sleeping（休眠时间） */ }; */ OOM 超出了内存分配 /// 收到低内存警告不一定会 Crash，因为有6秒钟的系统判断时间，6秒内内存下降了则不会 crash。发生 OOM 也不一定会收到低内存警告 /** 合理使用autoreleasepool, autoreleasepool对象是在Runloop结束时释放，在ARC下， 如果我们不断的申请内存， 我们需要手动的添加autoreleasepool， 避免短时间内内存猛涨发生OOM 内存分配: malloc用的是 malloc_zone_malloc, calloc用的是malloc_zone_calloc 在处理图片缩放时，ImageIO占用内存会比直接处理图片缩放小 */</summary></entry><entry><title type="html">IM总结</title><link href="http://localhost:4000/IM%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="IM总结" /><published>2020-05-25T00:00:00+08:00</published><updated>2020-05-25T00:00:00+08:00</updated><id>http://localhost:4000/IM%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/IM%E6%80%BB%E7%BB%93/">&lt;h5 id=&quot;socket长连接的创建与维护&quot;&gt;Socket长连接的创建与维护&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;所有数据收发流程，均通过Socket长连接完成，如何维护一个稳定Socket通道，是IM系统是否稳定的重要一环&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3370669f336a42688dd65794565fc414~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用连接请求接口，会开始连接的创建过程，创建成功后，会完成鉴权操作，当创建和鉴权都完成后，会开启消息收发线程，为了维持长连接，会有心跳机制，特别的，会开启一个心跳轮询线程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;心跳机制，是IM系统设计中的常见概念，简单的解释就是每隔若干时间发送一个固定信息给服务端，服务端收到后及时回复一个固定信息，如果服务端若干时间内没有收到客户端心跳信息则视客户端断开，同理如果客户端若干时间没有收到服务端心跳回值则视服务端断开&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-543f9422faad06d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当长连接创建成功后，会开启一个轮询线程，每隔一段时间发送心跳消息给服务器端，以维持长连接&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重连流程
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-21aa979e280bb85f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;聊天会话数据加载策略&quot;&gt;聊天会话数据加载策略&lt;/h4&gt;
&lt;p&gt;用户聊天时，需要将已经发送和接收到的聊天信息保存到本地。而不是每次都拉取历史数据。以达到节约流量和无网络状态下也查看数据的效果&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IM会话首次请求数据流程
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-521b1c2cae77ae39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IM下拉获取历史数据流程
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-a7e9213bba7026ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IM单条消息发送持久化方案
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-3aa4b8107e5ca390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IM单条数据重发流程
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-f8177e4089dc6d9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;消息回执&quot;&gt;消息回执&lt;/h5&gt;
&lt;p&gt;发送方增加已送到和未送达的状态，接收方收到消息后，给服务器返回已收到消息的通知，服务器再推送给发送方该状态，如果没有收到接收方回执，服务器可尝试重新推送。发送方接受到接收方的收到回执后，更新发送状态已发送，如果未收到，则显示未送达。为了防止接收方回执丢失，接收方接收消息时候，可维护本地去重队列&lt;/p&gt;

&lt;h4 id=&quot;im消息的逻辑流程&quot;&gt;IM消息的逻辑流程&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;消息接收：
网络模块通过跟IM服务端保持的长连接接收IM消息；&lt;/li&gt;
  &lt;li&gt;消息入库：
网络模块会将IM消息存入本地数据库，即信件投入了韩梅梅家的邮箱。网络模块就是邮递员，本地数据库就是韩梅梅家的邮箱；&lt;/li&gt;
  &lt;li&gt;消息展示：
界面模块获取发送人头像，和消息内容一起显示在聊天界面上。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;传输层协议-传输格式&quot;&gt;传输层协议 传输格式&lt;/h4&gt;

&lt;p&gt;数据协议存在文本协议和二进制协议两种类型&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文本协议直观、描述性强，容易理解、便与调试，并且协议修改方便，但是数据冗余较多，安全性稍差；&lt;/li&gt;
  &lt;li&gt;二进制协议格式精简、冗余数据少，窃听成本更高，但是数据不直观、调试略微复杂，使用、升级维护都需要约定好规则。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为优化App的网络请求速度和减小数据包大小，并配合接入层后台往C++框架改造，我们App的接入层网络数据传输协议切换成了二进制协议。协议数据包的定义统一采用协议头+业务包体(协议内容)的方式，协议头中用若干比特位定义协议版本号、数据包长度等信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-da1cba77e49d3863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;请求结构体&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-7ce50dff6e3aa29d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;响应结构体&quot; /&gt;&lt;/p&gt;

&lt;p&gt;请求协议的协议头中包含业务标志、协议版本号和数据包长度，服务端只处理以业务标志开头的数据包：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;截取协议头后，用PkgReq结构体解析协议头中指定长度的数据包。&lt;/li&gt;
  &lt;li&gt;PkgReq包括明文的协议包头PkgReqHead和密文的二进制流。&lt;/li&gt;
  &lt;li&gt;PkgReqHead中会包括客户端生成的请求序列号，密文的加密方式、压缩方式等信息，用这些信息解开加密压缩过的PkgReqBody。&lt;/li&gt;
  &lt;li&gt;PkgReqBody包含通用请求数据ReqHead和业务请求数据ReqBody数组。&lt;/li&gt;
  &lt;li&gt;ReqHead中主要包括用户的设备信息、App版本信息、账号信息、网络环境等等基础信息，ReqBody则是具体请求命令字和业务请求结构体的封装。&lt;/li&gt;
  &lt;li&gt;若是多个命令字的合并请求则会有多个ReqBody，而ReqHead只需要有一份。&lt;/li&gt;
  &lt;li&gt;后台路由层根据ReqBody中的命令字cmdid将ReqBody中的businessReqBody字段转发到具体的后台服务进行处理。&lt;/li&gt;
  &lt;li&gt;并且ReqHead中设计了guid字段，后台会存储用户的设备信息并且给用户分配唯一的guid，客户端拿到guid之后，后续的请求就不需要上报不变的设备信息字段，只需要上传guid，后端可以根据guid按需获取用户设备信息，减小请求数据量。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;响应协议与请求协议的整体结构类似，由于响应需要返回错误码或返回码给客户端，并且存在合并请求，因此设计了两层返回码。在RspHead中有整体返回码iRet，作为路由层整体的处理结果；每个RspBody中还有ret，作为该命令字对应的后台服务的返回结果。每个RspBody中的businessRspBody在iRet和ret同时有效时才能用该命令字对应的响应结构体进行解包&lt;/p&gt;

&lt;h4 id=&quot;传输安全&quot;&gt;传输安全&lt;/h4&gt;

&lt;p&gt;二进制协议方案与文本协议方案类似，都需要考虑数据安全性的问题。二进制协议由于传输的数据包是二进制流，抓包并不能直接看到结构体，例如我们采用的jce协议，必须知道完整的数据格式才能解析出原始数据。在我们的方案中还采用了https、对协议中的内容数据PkgReqBody/PkgRspBody进行先压缩后加密等操作保证安全性&lt;/p&gt;

&lt;p&gt;二进制协议方案中，采用的AES加密，与文本协议不同的是采用AES的GCM模式。AES作为一种分组对称加密算法，需要对明文进行分组，分组长度可为128或256bits，有ECB，CBC，CTR等多种模式，这里不做具体介绍。GCM模式可以提供对消息的加密和完整性校验，具体原理这里不作详细介绍，可以参考文章《&lt;a href=&quot;https://blog.csdn.net/t0mato_/article/details/53160772&quot;&gt;什么是 AES-GCM加密算法&lt;/a&gt;》。AES-GCM加密也需要密钥key、初始向量iv，并且加密之后除了得到密文，还会得到消息校验码。在数据接收方可以通过这个校验码校验密文是否有篡改。在具体实现中，为增强安全性，iv由请求序列号和key按照一定规则动态生成，并将加密得到的校验码填写在协议包头PkgReqHead/PkgRspHead中，在解密时需要作为验证条件&lt;/p&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">Socket长连接的创建与维护 所有数据收发流程，均通过Socket长连接完成，如何维护一个稳定Socket通道，是IM系统是否稳定的重要一环 用连接请求接口，会开始连接的创建过程，创建成功后，会完成鉴权操作，当创建和鉴权都完成后，会开启消息收发线程，为了维持长连接，会有心跳机制，特别的，会开启一个心跳轮询线程。 心跳机制，是IM系统设计中的常见概念，简单的解释就是每隔若干时间发送一个固定信息给服务端，服务端收到后及时回复一个固定信息，如果服务端若干时间内没有收到客户端心跳信息则视客户端断开，同理如果客户端若干时间没有收到服务端心跳回值则视服务端断开 当长连接创建成功后，会开启一个轮询线程，每隔一段时间发送心跳消息给服务器端，以维持长连接 重连流程 聊天会话数据加载策略 用户聊天时，需要将已经发送和接收到的聊天信息保存到本地。而不是每次都拉取历史数据。以达到节约流量和无网络状态下也查看数据的效果 IM会话首次请求数据流程 IM下拉获取历史数据流程 IM单条消息发送持久化方案 IM单条数据重发流程 消息回执 发送方增加已送到和未送达的状态，接收方收到消息后，给服务器返回已收到消息的通知，服务器再推送给发送方该状态，如果没有收到接收方回执，服务器可尝试重新推送。发送方接受到接收方的收到回执后，更新发送状态已发送，如果未收到，则显示未送达。为了防止接收方回执丢失，接收方接收消息时候，可维护本地去重队列 IM消息的逻辑流程 消息接收： 网络模块通过跟IM服务端保持的长连接接收IM消息； 消息入库： 网络模块会将IM消息存入本地数据库，即信件投入了韩梅梅家的邮箱。网络模块就是邮递员，本地数据库就是韩梅梅家的邮箱； 消息展示： 界面模块获取发送人头像，和消息内容一起显示在聊天界面上。 传输层协议 传输格式 数据协议存在文本协议和二进制协议两种类型 文本协议直观、描述性强，容易理解、便与调试，并且协议修改方便，但是数据冗余较多，安全性稍差； 二进制协议格式精简、冗余数据少，窃听成本更高，但是数据不直观、调试略微复杂，使用、升级维护都需要约定好规则。 为优化App的网络请求速度和减小数据包大小，并配合接入层后台往C++框架改造，我们App的接入层网络数据传输协议切换成了二进制协议。协议数据包的定义统一采用协议头+业务包体(协议内容)的方式，协议头中用若干比特位定义协议版本号、数据包长度等信息 请求协议的协议头中包含业务标志、协议版本号和数据包长度，服务端只处理以业务标志开头的数据包： 截取协议头后，用PkgReq结构体解析协议头中指定长度的数据包。 PkgReq包括明文的协议包头PkgReqHead和密文的二进制流。 PkgReqHead中会包括客户端生成的请求序列号，密文的加密方式、压缩方式等信息，用这些信息解开加密压缩过的PkgReqBody。 PkgReqBody包含通用请求数据ReqHead和业务请求数据ReqBody数组。 ReqHead中主要包括用户的设备信息、App版本信息、账号信息、网络环境等等基础信息，ReqBody则是具体请求命令字和业务请求结构体的封装。 若是多个命令字的合并请求则会有多个ReqBody，而ReqHead只需要有一份。 后台路由层根据ReqBody中的命令字cmdid将ReqBody中的businessReqBody字段转发到具体的后台服务进行处理。 并且ReqHead中设计了guid字段，后台会存储用户的设备信息并且给用户分配唯一的guid，客户端拿到guid之后，后续的请求就不需要上报不变的设备信息字段，只需要上传guid，后端可以根据guid按需获取用户设备信息，减小请求数据量。 响应协议与请求协议的整体结构类似，由于响应需要返回错误码或返回码给客户端，并且存在合并请求，因此设计了两层返回码。在RspHead中有整体返回码iRet，作为路由层整体的处理结果；每个RspBody中还有ret，作为该命令字对应的后台服务的返回结果。每个RspBody中的businessRspBody在iRet和ret同时有效时才能用该命令字对应的响应结构体进行解包 传输安全 二进制协议方案与文本协议方案类似，都需要考虑数据安全性的问题。二进制协议由于传输的数据包是二进制流，抓包并不能直接看到结构体，例如我们采用的jce协议，必须知道完整的数据格式才能解析出原始数据。在我们的方案中还采用了https、对协议中的内容数据PkgReqBody/PkgRspBody进行先压缩后加密等操作保证安全性 二进制协议方案中，采用的AES加密，与文本协议不同的是采用AES的GCM模式。AES作为一种分组对称加密算法，需要对明文进行分组，分组长度可为128或256bits，有ECB，CBC，CTR等多种模式，这里不做具体介绍。GCM模式可以提供对消息的加密和完整性校验，具体原理这里不作详细介绍，可以参考文章《什么是 AES-GCM加密算法》。AES-GCM加密也需要密钥key、初始向量iv，并且加密之后除了得到密文，还会得到消息校验码。在数据接收方可以通过这个校验码校验密文是否有篡改。在具体实现中，为增强安全性，iv由请求序列号和key按照一定规则动态生成，并将加密得到的校验码填写在协议包头PkgReqHead/PkgRspHead中，在解密时需要作为验证条件</summary></entry></feed>