<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-07-14T23:31:53+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">风车大战骑士</title><subtitle>生活不止眼前的苟且，还有诗和远方</subtitle><entry><title type="html">查理芒格传读书笔记</title><link href="http://localhost:4000/%E6%9F%A5%E7%90%86%E8%8A%92%E6%A0%BC%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="查理芒格传读书笔记" /><published>2019-07-14T00:00:00+08:00</published><updated>2019-07-14T00:00:00+08:00</updated><id>http://localhost:4000/%E6%9F%A5%E7%90%86%E8%8A%92%E6%A0%BC%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/%E6%9F%A5%E7%90%86%E8%8A%92%E6%A0%BC%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">&lt;h4 id=&quot;记录在看查理芒格传的笔记&quot;&gt;记录在看《查理·芒格传》的笔记&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;你一定要和高水准的人做生意，永远不要和一头猪玩摔跤，因为如果你这么做了，你们两个都会变脏，但是猪会乐在其中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;好企业和差企业之间的区别在于，在好企业里你会做出一个接一个的轻松决定，而差企业的决定则常常是痛苦万分的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我本人是一个传记狂，比如你要是和亚当•斯密成了朋友，那你一定会把经济学得更好。跟离世的伟人交朋友，这听起来很滑稽，但如果你一生都这样做，你会受益匪浅。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;投资游戏说到底就是要比其他人对未来做出更准确的预言。要如何做到呢？一种方法是将这种竞争在有限的几个区域中进行。如果你试图预言所有事情的未来，你会因为缺乏专长而失败。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你想变得聪明，你就必须不停地问为什么？为什么？为什么？同时你还必须将答案和有条理的深层理论联系起来。你必须知道那些最主要的理论。这稍微会有些费力，但充满乐趣。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们大多数人做决策时都会存在一个问题：不考虑这个决策可能带来的长远影响。这时，你可以根据 10 → 10 → 10 原则来考虑所做的决策可能带来的长远影响。这个原则就是：&lt;br /&gt;
这个决策在 10 分钟后，会产生什么影响？&lt;br /&gt;
这个决策在 10 个月后，会产生什么影响？&lt;br /&gt;
这个决策在 10 年后，会产生什么影响？&lt;br /&gt;
在做决策时如果能践行 10 → 10 → 10 原则，这将有助于你在决策时免受感性因素的影响，迫使你考虑到这个决策可能会带来的长远影响，从而做出更加明智的决策&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="读书笔记" /><summary type="html">记录在看《查理·芒格传》的笔记 你一定要和高水准的人做生意，永远不要和一头猪玩摔跤，因为如果你这么做了，你们两个都会变脏，但是猪会乐在其中 好企业和差企业之间的区别在于，在好企业里你会做出一个接一个的轻松决定，而差企业的决定则常常是痛苦万分的。 我本人是一个传记狂，比如你要是和亚当•斯密成了朋友，那你一定会把经济学得更好。跟离世的伟人交朋友，这听起来很滑稽，但如果你一生都这样做，你会受益匪浅。 投资游戏说到底就是要比其他人对未来做出更准确的预言。要如何做到呢？一种方法是将这种竞争在有限的几个区域中进行。如果你试图预言所有事情的未来，你会因为缺乏专长而失败。 如果你想变得聪明，你就必须不停地问为什么？为什么？为什么？同时你还必须将答案和有条理的深层理论联系起来。你必须知道那些最主要的理论。这稍微会有些费力，但充满乐趣。 我们大多数人做决策时都会存在一个问题：不考虑这个决策可能带来的长远影响。这时，你可以根据 10 → 10 → 10 原则来考虑所做的决策可能带来的长远影响。这个原则就是： 这个决策在 10 分钟后，会产生什么影响？ 这个决策在 10 个月后，会产生什么影响？ 这个决策在 10 年后，会产生什么影响？ 在做决策时如果能践行 10 → 10 → 10 原则，这将有助于你在决策时免受感性因素的影响，迫使你考虑到这个决策可能会带来的长远影响，从而做出更加明智的决策</summary></entry><entry><title type="html">财报入门学习</title><link href="http://localhost:4000/%E8%B4%A2%E6%8A%A5%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/" rel="alternate" type="text/html" title="财报入门学习" /><published>2019-07-07T00:00:00+08:00</published><updated>2019-07-07T00:00:00+08:00</updated><id>http://localhost:4000/%E8%B4%A2%E6%8A%A5%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0</id><content type="html" xml:base="http://localhost:4000/%E8%B4%A2%E6%8A%A5%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/">&lt;h4 id=&quot;记录金融入门学习&quot;&gt;记录金融入门学习&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;巴菲特：&lt;/strong&gt;买股票的本质是投资公司&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;彼得林奇：&lt;/strong&gt;当你读不懂某一公司的财务情况时，不要投资。股市的最大的亏损源于投资了在资产负债方面很糟糕的公司。先看资产负债表，搞清该公司是否有偿债能力，然后再投钱冒险&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;金融书籍记录&quot;&gt;金融书籍记录&lt;/h5&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;彼得林奇 &lt;在华尔街的崛起&gt;&lt;/在华尔街的崛起&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;查理芒格 &lt;查理芒格传&gt;&lt;/查理芒格传&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;瑞达利欧 &lt;原则&gt;&lt;/原则&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;财务报表学习&quot;&gt;财务报表学习&lt;/h5&gt;
&lt;p&gt;财务报表分三类&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;利润表&lt;/li&gt;
  &lt;li&gt;资产负债表&lt;/li&gt;
  &lt;li&gt;现金流量表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在看公司公司财报前，先看会计师审计报告，在年报的第十一节，《审计意见》，审计意见反映了审计师的心声
&lt;img src=&quot;http://fdfs.xmcdn.com/group49/M0A/82/E6/wKgKl1vyIimQcOpPAAFtInzQd2A978_mobile_large.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;利润表&quot;&gt;利润表&lt;/h5&gt;
&lt;p&gt;形象解释
&lt;img src=&quot;http://fdfs.xmcdn.com/group53/M09/02/0A/wKgLfFv7l6OyBzn2AAFRrI5yisI426_mobile_large.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;净利润中包含了企业的应收账款，所以并不能单单以净利润在决定公司运营好坏，还需结合现金流量表和资产负债表&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;扣非净利润&lt;/li&gt;
  &lt;li&gt;归属于母公司所有者的净利润&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;资产负债表&quot;&gt;资产负债表&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;资产&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;负债&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;流动资产&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;说明&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;非流动资产&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;说明&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;负债&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;说明&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;所有者权益&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;货币资金&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;企业的现金存款&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;固定资产&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;非货币资产，(房屋，设备，机器等)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;银行负债&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;银行贷款&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;股东出钱&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;应收账款&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;发了货，还没结账，(坏账准备)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;生物性资产&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;农林牧渔行业&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;存货&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;看行业，更新快的行业存货少好&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无形资产&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;专利权，著作权，土地使用权&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;表格在手机上会有变形，截图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/12/ZfWbHP.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://fdfs.xmcdn.com/group53/M07/D7/2D/wKgLcVwKI92jI9JaAAGHfFHmyt0046_mobile_large.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;现金流量表&quot;&gt;现金流量表&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;序号&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;类别&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;经营活动产生的现金流量&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;利润表收入支出现金的变化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;投资活动产生的现金流量&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;资产负债表的固定资产变动情况&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;筹资活动产生的现金流量&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;资产负债表的负债和所有者权益变动情况&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h6 id=&quot;1-经营活动现金流&quot;&gt;1. 经营活动现金流&lt;/h6&gt;
&lt;p&gt;有公开数据的企业，直接看企业经营活动产生的现金流，这是现金流量表的核心。因为刚刚我们刚讲了，企业的经营能力才是我们投资者最应该看重的。而经营活动现金流，就代表着经营能力的强弱。&lt;/p&gt;

&lt;p&gt;如果经营活动现金流量净额，长期为负的话（银行证券保险除外），代表企业日子不太好过，入不敷出，这类企业不用考虑投资。只有经营活动现金流量净额是正数，说明它才是一家正常的企业。&lt;/p&gt;

&lt;h6 id=&quot;2-投资活动现金流&quot;&gt;2. 投资活动现金流&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;http://fdfs.xmcdn.com/group52/M01/59/BF/wKgLcFwZzTmDkUDgAAFRpaHBRiY184_mobile_large.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;3-筹资活动中了解企业的融资情况&quot;&gt;3. 筹资活动中了解企业的融资情况&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;http://fdfs.xmcdn.com/group52/M01/59/E3/wKgLe1wZzTqS3C3gAADXdXRFjFY717_mobile_large.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;类型一的企业&quot;&gt;类型一、“+++”的企业&lt;/h6&gt;

&lt;p&gt;三项都为正的企业。表明上看起来，这样的公司特别不错。经营活动现金为正数，现金源源不断。但是有一个问题，就是企业经营赚了钱以后，为什么不向外投资呢？反而还需要筹资呢？难道都把钱放在银行账户上数钱玩吗？这类型的企业，要么就是即将大规模的开展对外大规模的投资活动，所以在筹集本钱。要么就很可能是起了歹心，借着上市公司的躯壳在赚钱。所以，如果是这三项都是正的企业，建议我们要谨慎观察一下。如果查阅很多材料，都看不出来企业有大投资的动作。建议这类型的企业，我们也淘汰掉。&lt;/p&gt;

&lt;h6 id=&quot;类型二-的企业&quot;&gt;类型二、“++-”的企业&lt;/h6&gt;

&lt;p&gt;这类型的企业，经营活动现金流为正，说明企业经营情况还不错。投资活动现金流为正，说明以前投资的资产，带来了利息等方面的收入。或者是变卖了资产，产生了收入。一般来说，资产带来的收益比较多，因为企业变卖资产的情况很小。筹资活动现金流为负数，要么就是还了贷款，要么就是给股东分红。这类的企业，如果投资现金流，不是变卖资产所得。而经营现金流和投资现金流，足以覆盖筹资现金流的流出。我们就可以初步判断，这家公司是健康发展的。&lt;/p&gt;

&lt;h6 id=&quot;类型三-的企业&quot;&gt;类型三、“+-+”的企业&lt;/h6&gt;

&lt;p&gt;这类企业，经营活动现金流同样为正，说明企业赚钱。同时筹资活动现金流为正，但是投资活动现金流是负。说明企业现在正在大力的扩大规模。需要把钱投入到新的项目中。这类企业有一个问题，就是所投资的项目如果创造辉煌，企业会高速的增长。反之，企业如果投资失败，会影响企业后期的发展。&lt;/p&gt;

&lt;p&gt;这类型的企业，很考验我们对行业发展的一个判断。&lt;/p&gt;

&lt;h6 id=&quot;类型四的企业&quot;&gt;类型四、“+–”的企业&lt;/h6&gt;

&lt;p&gt;经营活动现金流为正，同样说明企业赚钱。投资活动现金流为负，说明企业也在稳步的扩张。筹资活动现金流为负，说明企业还了贷款，或者给股东分红了。也就是说，企业靠着经营现金流的流入，实施了投资，并且同时还了贷款或给股东分红。这类型的企业是四种画像里面最好的企业，这种企业自我造血能力最强。靠着自己赚的钱可以去投资其他的项目，同时赚的钱还可以给股东分红或者偿还贷款。这类企业是最具备投资价值的&lt;/p&gt;</content><author><name></name></author><category term="金融" /><summary type="html">记录金融入门学习 巴菲特：买股票的本质是投资公司 彼得林奇：当你读不懂某一公司的财务情况时，不要投资。股市的最大的亏损源于投资了在资产负债方面很糟糕的公司。先看资产负债表，搞清该公司是否有偿债能力，然后再投钱冒险 金融书籍记录 彼得林奇 查理芒格 瑞达利欧 财务报表学习 财务报表分三类 利润表 资产负债表 现金流量表 在看公司公司财报前，先看会计师审计报告，在年报的第十一节，《审计意见》，审计意见反映了审计师的心声 利润表 形象解释 净利润中包含了企业的应收账款，所以并不能单单以净利润在决定公司运营好坏，还需结合现金流量表和资产负债表 扣非净利润 归属于母公司所有者的净利润 资产负债表 资产       负债       流动资产 说明 非流动资产 说明 负债 说明 所有者权益 说明 货币资金 企业的现金存款 固定资产 非货币资产，(房屋，设备，机器等) 银行负债 银行贷款 股东出钱   应收账款 发了货，还没结账，(坏账准备) 生物性资产 农林牧渔行业         存货 看行业，更新快的行业存货少好 无形资产 专利权，著作权，土地使用权         表格在手机上会有变形，截图如下 现金流量表 序号 类别 说明 1 经营活动产生的现金流量 利润表收入支出现金的变化 2 投资活动产生的现金流量 资产负债表的固定资产变动情况 3 筹资活动产生的现金流量 资产负债表的负债和所有者权益变动情况 1. 经营活动现金流 有公开数据的企业，直接看企业经营活动产生的现金流，这是现金流量表的核心。因为刚刚我们刚讲了，企业的经营能力才是我们投资者最应该看重的。而经营活动现金流，就代表着经营能力的强弱。 如果经营活动现金流量净额，长期为负的话（银行证券保险除外），代表企业日子不太好过，入不敷出，这类企业不用考虑投资。只有经营活动现金流量净额是正数，说明它才是一家正常的企业。 2. 投资活动现金流 3. 筹资活动中了解企业的融资情况 类型一、“+++”的企业 三项都为正的企业。表明上看起来，这样的公司特别不错。经营活动现金为正数，现金源源不断。但是有一个问题，就是企业经营赚了钱以后，为什么不向外投资呢？反而还需要筹资呢？难道都把钱放在银行账户上数钱玩吗？这类型的企业，要么就是即将大规模的开展对外大规模的投资活动，所以在筹集本钱。要么就很可能是起了歹心，借着上市公司的躯壳在赚钱。所以，如果是这三项都是正的企业，建议我们要谨慎观察一下。如果查阅很多材料，都看不出来企业有大投资的动作。建议这类型的企业，我们也淘汰掉。 类型二、“++-”的企业 这类型的企业，经营活动现金流为正，说明企业经营情况还不错。投资活动现金流为正，说明以前投资的资产，带来了利息等方面的收入。或者是变卖了资产，产生了收入。一般来说，资产带来的收益比较多，因为企业变卖资产的情况很小。筹资活动现金流为负数，要么就是还了贷款，要么就是给股东分红。这类的企业，如果投资现金流，不是变卖资产所得。而经营现金流和投资现金流，足以覆盖筹资现金流的流出。我们就可以初步判断，这家公司是健康发展的。 类型三、“+-+”的企业 这类企业，经营活动现金流同样为正，说明企业赚钱。同时筹资活动现金流为正，但是投资活动现金流是负。说明企业现在正在大力的扩大规模。需要把钱投入到新的项目中。这类企业有一个问题，就是所投资的项目如果创造辉煌，企业会高速的增长。反之，企业如果投资失败，会影响企业后期的发展。 这类型的企业，很考验我们对行业发展的一个判断。 类型四、“+–”的企业 经营活动现金流为正，同样说明企业赚钱。投资活动现金流为负，说明企业也在稳步的扩张。筹资活动现金流为负，说明企业还了贷款，或者给股东分红了。也就是说，企业靠着经营现金流的流入，实施了投资，并且同时还了贷款或给股东分红。这类型的企业是四种画像里面最好的企业，这种企业自我造血能力最强。靠着自己赚的钱可以去投资其他的项目，同时赚的钱还可以给股东分红或者偿还贷款。这类企业是最具备投资价值的</summary></entry><entry><title type="html">PMP考试总结</title><link href="http://localhost:4000/PMP%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="PMP考试总结" /><published>2019-06-22T00:00:00+08:00</published><updated>2019-06-22T00:00:00+08:00</updated><id>http://localhost:4000/PMP%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/PMP%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/">&lt;h3 id=&quot;记录下在备考pmp的一些知识&quot;&gt;记录下在备考PMP的一些知识&lt;/h3&gt;

&lt;h4 id=&quot;pmp十大知识领域&quot;&gt;PMP十大知识领域&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;整合管理&lt;/li&gt;
  &lt;li&gt;范围管理&lt;/li&gt;
  &lt;li&gt;进度管理&lt;/li&gt;
  &lt;li&gt;成本管理&lt;/li&gt;
  &lt;li&gt;质量管理&lt;/li&gt;
  &lt;li&gt;资源管理&lt;/li&gt;
  &lt;li&gt;沟通管理&lt;/li&gt;
  &lt;li&gt;风险管理&lt;/li&gt;
  &lt;li&gt;采购管理&lt;/li&gt;
  &lt;li&gt;相关方管理&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;五大过程组&quot;&gt;五大过程组&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;启动&lt;/li&gt;
  &lt;li&gt;规划&lt;/li&gt;
  &lt;li&gt;执行&lt;/li&gt;
  &lt;li&gt;监控&lt;/li&gt;
  &lt;li&gt;收尾&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;共131个工具和技术&quot;&gt;共131个工具和技术&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据收集技术。用于从各种渠道收集数据与信息。共有九种数据收集工具与技术。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据分析技术。用于组织、评估和评价数据与信息。共有 27 种数据分析工具与技术。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据表现技术。用于显示用来传递数据和信息的图形方式或其他方法。共有 15 种数据表现工具与技术。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;决策技术。用于从不同备选方案选择行动方案。共有两种决策工具与技术。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;沟通技巧。用于在相关方之间传递信息。共有两种沟通技巧工具与技术。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;人际关系与团队技能。用于有效地领导团队成员和其他相关方并与之进行互动。共有 17 种人际关系与团队技能工具与技术。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://i.bmp.ovh/imgs/2019/07/93c0798878114870.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="PMP" /><summary type="html">记录下在备考PMP的一些知识 PMP十大知识领域 整合管理 范围管理 进度管理 成本管理 质量管理 资源管理 沟通管理 风险管理 采购管理 相关方管理 五大过程组 启动 规划 执行 监控 收尾 共131个工具和技术 数据收集技术。用于从各种渠道收集数据与信息。共有九种数据收集工具与技术。 数据分析技术。用于组织、评估和评价数据与信息。共有 27 种数据分析工具与技术。 数据表现技术。用于显示用来传递数据和信息的图形方式或其他方法。共有 15 种数据表现工具与技术。 决策技术。用于从不同备选方案选择行动方案。共有两种决策工具与技术。 沟通技巧。用于在相关方之间传递信息。共有两种沟通技巧工具与技术。 人际关系与团队技能。用于有效地领导团队成员和其他相关方并与之进行互动。共有 17 种人际关系与团队技能工具与技术。</summary></entry><entry><title type="html">2019书单</title><link href="http://localhost:4000/2019%E4%B9%A6%E5%8D%95/" rel="alternate" type="text/html" title="2019书单" /><published>2019-04-14T00:00:00+08:00</published><updated>2019-04-14T00:00:00+08:00</updated><id>http://localhost:4000/2019%E4%B9%A6%E5%8D%95</id><content type="html" xml:base="http://localhost:4000/2019%E4%B9%A6%E5%8D%95/">&lt;h3 id=&quot;记录下2019年要看的书单&quot;&gt;记录下2019年要看的书单&lt;/h3&gt;
&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;在华尔街的崛起&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;原则&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;查理·芒格传&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;红与黑&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;国富论&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;PMP全解读&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;[ ]&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="读书笔记" /><summary type="html">记录下2019年要看的书单 在华尔街的崛起 原则 查理·芒格传 红与黑 国富论 PMP全解读 [ ]</summary></entry><entry><title type="html">转战Swift</title><link href="http://localhost:4000/OC%E6%92%B0%E5%86%99swift/" rel="alternate" type="text/html" title="转战Swift" /><published>2018-07-22T00:00:00+08:00</published><updated>2018-07-22T00:00:00+08:00</updated><id>http://localhost:4000/OC%E6%92%B0%E5%86%99swift</id><content type="html" xml:base="http://localhost:4000/OC%E6%92%B0%E5%86%99swift/">&lt;h4 id=&quot;swift相对oc的优势&quot;&gt;swift相对OC的优势&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Swift容易阅读，语法和文件结构简易化。&lt;/li&gt;
  &lt;li&gt;Swift更易于维护，文件分离后结构更清晰。&lt;/li&gt;
  &lt;li&gt;Swift更加安全，它是类型安全的语言。&lt;/li&gt;
  &lt;li&gt;Swift代码更少，简洁的语法，可以省去大量冗余代码&lt;/li&gt;
  &lt;li&gt;Swift速度更快，运算性能更高。&lt;/li&gt;
  &lt;li&gt;Swift是面向协议的语言&lt;/li&gt;
  &lt;li&gt;swift 用户自己创建的Class，不需要Import， 只需Import第三方即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;swift相对oc的劣势&quot;&gt;swift相对OC的劣势&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Swift没有OC的Runtime特性&lt;/li&gt;
  &lt;li&gt;OC可以和C++混编&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;swift总结&quot;&gt;swift总结&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;swift严格区分类型， Int 和 CGFloat 不可进行运算，必须转化为同一类型&lt;/li&gt;
  &lt;li&gt;swift可选类型使用非常多， 在可选类型进行强制取值时，一定要判空，否则会抛异常， 区分? 和！在解包时可以使用  &lt;code class=&quot;highlighter-rouge&quot;&gt; if let&lt;/code&gt;  和  &lt;code class=&quot;highlighter-rouge&quot;&gt;guard&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;swift引用了区间运算符 &lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;..&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="iOS" /><category term="Swift" /><summary type="html">swift相对OC的优势 Swift容易阅读，语法和文件结构简易化。 Swift更易于维护，文件分离后结构更清晰。 Swift更加安全，它是类型安全的语言。 Swift代码更少，简洁的语法，可以省去大量冗余代码 Swift速度更快，运算性能更高。 Swift是面向协议的语言 swift 用户自己创建的Class，不需要Import， 只需Import第三方即可 swift相对OC的劣势 Swift没有OC的Runtime特性 OC可以和C++混编 swift总结 swift严格区分类型， Int 和 CGFloat 不可进行运算，必须转化为同一类型 swift可选类型使用非常多， 在可选类型进行强制取值时，一定要判空，否则会抛异常， 区分? 和！在解包时可以使用 if let 和 guard swift引用了区间运算符 ... 和 ..&amp;lt;</summary></entry><entry><title type="html">二叉树笔记</title><link href="http://localhost:4000/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="alternate" type="text/html" title="二叉树笔记" /><published>2018-06-24T00:00:00+08:00</published><updated>2018-06-24T00:00:00+08:00</updated><id>http://localhost:4000/%E4%BA%8C%E5%8F%89%E6%A0%91</id><content type="html" xml:base="http://localhost:4000/%E4%BA%8C%E5%8F%89%E6%A0%91/">&lt;h4 id=&quot;树一种非线性的存储结构具有一对多关系的元素的集合&quot;&gt;“树”：一种非线性的存储结构，具有“一对多”关系的元素的集合&lt;/h4&gt;
&lt;p&gt;n(n &amp;gt;= 0)个结点的有限集合，n=0时是一棵空树，对于一棵非空树具有以下特性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有且仅有一个根节点(ROOT)&lt;/li&gt;
  &lt;li&gt;当n&amp;gt;1时，其余的结点可分为m(m&amp;gt;0)个互不相交的有限集，其中每个集合本身也是一棵树，称为根的子树&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;
	&lt;img src=&quot;http://data.biancheng.net/uploads/allimg/170830/2-1FS0094003158.png&quot; alt=&quot;树&quot; style=&quot;width:80%&quot; /&gt;
&lt;/center&gt;
&lt;h4 id=&quot;树--基本术语&quot;&gt;“树”  基本术语&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;结点：	树结构存储的每一个数据元素称为结点
   度：	一个结点拥有的子树数(degree)  一棵树中的最大的度数为该树的度&lt;/li&gt;
  &lt;li&gt;叶子结点：  度数为0的结点(终端结点)
   开始结点：	根结点
   分支结点：  度数不为0的结点(非终端结点)	
   层次：	  从根开始算起，根为第一层，其余结点的层次等于其双亲结点的层数+1&lt;/li&gt;
  &lt;li&gt;深度(高度)：树种结点的最大层次
   有序树：	树中结点的各子树从左至右依次有序且不能交换&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;二叉树&quot;&gt;二叉树&lt;/h4&gt;
&lt;p&gt;每个结点至多只有两棵子树，或者是空集，或者一个根结点及两颗互不相交的分别作为这个根的左子树，右子树组成&lt;/p&gt;
&lt;h4 id=&quot;二叉树性质&quot;&gt;二叉树性质&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;二叉树中，第 i 层最多有2^i-1个结点。&lt;/li&gt;
  &lt;li&gt;如果二叉树的深度为 K，那么此二叉树最多有2\^K-1个结点。&lt;/li&gt;
  &lt;li&gt;二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。&lt;/li&gt;
&lt;/ol&gt;

&lt;center&gt;
	&lt;img src=&quot;http://data.biancheng.net/uploads/allimg/170830/2-1FS0103951Y1.png&quot; alt=&quot;二叉树&quot; style=&quot;width:50%&quot; /&gt;
&lt;/center&gt;

&lt;h4 id=&quot;完全二叉树特有的性质&quot;&gt;完全二叉树特有的性质&lt;/h4&gt;
&lt;p&gt;n个结点的完全二叉树的深度为log&lt;sub&gt;2&lt;/sub&gt;b+1&lt;/p&gt;</content><author><name></name></author><category term="数据结构" /><summary type="html">“树”：一种非线性的存储结构，具有“一对多”关系的元素的集合 n(n &amp;gt;= 0)个结点的有限集合，n=0时是一棵空树，对于一棵非空树具有以下特性 有且仅有一个根节点(ROOT) 当n&amp;gt;1时，其余的结点可分为m(m&amp;gt;0)个互不相交的有限集，其中每个集合本身也是一棵树，称为根的子树 “树” 基本术语 结点： 树结构存储的每一个数据元素称为结点 度： 一个结点拥有的子树数(degree) 一棵树中的最大的度数为该树的度 叶子结点： 度数为0的结点(终端结点) 开始结点： 根结点 分支结点： 度数不为0的结点(非终端结点) 层次： 从根开始算起，根为第一层，其余结点的层次等于其双亲结点的层数+1 深度(高度)：树种结点的最大层次 有序树： 树中结点的各子树从左至右依次有序且不能交换 二叉树 每个结点至多只有两棵子树，或者是空集，或者一个根结点及两颗互不相交的分别作为这个根的左子树，右子树组成 二叉树性质 二叉树中，第 i 层最多有2^i-1个结点。 如果二叉树的深度为 K，那么此二叉树最多有2\^K-1个结点。 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。 完全二叉树特有的性质 n个结点的完全二叉树的深度为log2b+1</summary></entry><entry><title type="html">晓书馆之行</title><link href="http://localhost:4000/%E6%99%93%E4%B9%A6%E9%A6%86%E4%B9%8B%E8%A1%8C/" rel="alternate" type="text/html" title="晓书馆之行" /><published>2018-06-17T00:00:00+08:00</published><updated>2018-06-17T00:00:00+08:00</updated><id>http://localhost:4000/%E6%99%93%E4%B9%A6%E9%A6%86%E4%B9%8B%E8%A1%8C</id><content type="html" xml:base="http://localhost:4000/%E6%99%93%E4%B9%A6%E9%A6%86%E4%B9%8B%E8%A1%8C/">&lt;p&gt;自晓说三月份有一期高晓松讲它的书馆已经开馆了，一直想去看看它的书馆。毕竟他的晓说也是看了好几年了，基本上一期不落，还是挺佩服他的。多才多艺，满腹经纶，简直就是个移动的百科全书。昨天就专门去了位于杭州良渚晓书馆，一探究竟。从杭州东站直接做地铁到二号线良渚，然后直奔目的地。&lt;/p&gt;

&lt;p&gt;因为晓书馆馆内只能容纳三百人，所以需提前预约。来到门口，报预约的手机号可查到个人信息，即可入馆。负责门禁的貌似是个学生志愿者，说话很客气。进入到馆内，位于门口的左边便是一个服务台，有一个在看书工作人员，时不时抬头看看。在服务台旁边有一面有一面书柜，全是高晓松自己的书(下图二)，上面摆满了晓说，鱼羊野史。在书柜的对面的一个柱子上，刻了“晓书馆”的logo(下图一)&lt;/p&gt;
&lt;figure class=&quot;half&quot;&gt;
    &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-1517fa3eaea90d3f.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;书馆正门&quot; style=&quot;width:45%&quot; /&gt;
     &amp;gt;
    &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-240e542b4a198b1b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;书馆后面的小道&quot; style=&quot;width:45%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;进入书馆内，先大概转了一圈。在服务台旁边发现了一面留言墙，仔细看了下上面的留言。感觉很有意思，大概写留言的应该都是和我一样爱看晓说的吧，有给自己留的，也有给朋友留的，还有有祝福的留言，还有的在留言板上讲起来故事，还有一些灵魂画手画上了“矮大紧”，有种莫名的喜感，但感觉还是挺有才的。密密麻麻的留言贴了很多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-d48c82fcb9ab83d5.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;留言墙&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在书馆共分两层，大多数书集中在一楼，书架上放的书还有挺多的，各个种类的都有。放眼看去，书柜很高，大约有四五米的样子，如果想拿上面的书还是挺麻烦的。书柜旁边放了一些椅子，可供读者使用。书馆的尽头是一面玻璃墙，墙面有很多书桌和凳子。玻璃墙外便是一个水池，水池外面是一片绿油油的樱树，如果是三四月份，樱花盛开的时候那将会很漂亮。 二楼的书主要是一些儿童图书。由于是周末，二楼的很多人直接用坐垫坐在地上看书，也还有一些小朋友在玩耍。&lt;/p&gt;

&lt;figure class=&quot;half&quot;&gt;
    &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-db065c7a43b63c2a.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;书馆内&quot; style=&quot;width:45%&quot; /&gt;
     &amp;gt;
    &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-5145af777ccff467.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;书馆后面的小道&quot; style=&quot;width:45%&quot; /&gt;
&lt;/figure&gt;</content><author><name></name></author><category term="随笔" /><summary type="html">自晓说三月份有一期高晓松讲它的书馆已经开馆了，一直想去看看它的书馆。毕竟他的晓说也是看了好几年了，基本上一期不落，还是挺佩服他的。多才多艺，满腹经纶，简直就是个移动的百科全书。昨天就专门去了位于杭州良渚晓书馆，一探究竟。从杭州东站直接做地铁到二号线良渚，然后直奔目的地。 因为晓书馆馆内只能容纳三百人，所以需提前预约。来到门口，报预约的手机号可查到个人信息，即可入馆。负责门禁的貌似是个学生志愿者，说话很客气。进入到馆内，位于门口的左边便是一个服务台，有一个在看书工作人员，时不时抬头看看。在服务台旁边有一面有一面书柜，全是高晓松自己的书(下图二)，上面摆满了晓说，鱼羊野史。在书柜的对面的一个柱子上，刻了“晓书馆”的logo(下图一) &amp;gt; 进入书馆内，先大概转了一圈。在服务台旁边发现了一面留言墙，仔细看了下上面的留言。感觉很有意思，大概写留言的应该都是和我一样爱看晓说的吧，有给自己留的，也有给朋友留的，还有有祝福的留言，还有的在留言板上讲起来故事，还有一些灵魂画手画上了“矮大紧”，有种莫名的喜感，但感觉还是挺有才的。密密麻麻的留言贴了很多。 在书馆共分两层，大多数书集中在一楼，书架上放的书还有挺多的，各个种类的都有。放眼看去，书柜很高，大约有四五米的样子，如果想拿上面的书还是挺麻烦的。书柜旁边放了一些椅子，可供读者使用。书馆的尽头是一面玻璃墙，墙面有很多书桌和凳子。玻璃墙外便是一个水池，水池外面是一片绿油油的樱树，如果是三四月份，樱花盛开的时候那将会很漂亮。 二楼的书主要是一些儿童图书。由于是周末，二楼的很多人直接用坐垫坐在地上看书，也还有一些小朋友在玩耍。 &amp;gt;</summary></entry><entry><title type="html">转场动画小记</title><link href="http://localhost:4000/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E5%B0%8F%E8%AE%B0/" rel="alternate" type="text/html" title="转场动画小记" /><published>2018-03-17T00:00:00+08:00</published><updated>2018-03-17T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E5%B0%8F%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E5%B0%8F%E8%AE%B0/">&lt;h3 id=&quot;1-简单push动画和present动画&quot;&gt;1. 简单push动画和present动画&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self.navigationController.view.layer addAnimation:[self pushAnimation] forKey:@&quot;&quot;];
[self.navigationController pushViewController:[] animated:NO];

[self.view.window.layer addAnimation:[self presentAnimation] forKey:nil];
[self presentViewController:second animated:NO completion:nil]; 

//系统的API
- (void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;自定义push动画，然后在push时添加到navigationController中
CATransition -&amp;gt; CAAnimation -&amp;gt; NSObject&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    CATransition *transition = [CATransition animation];
    transition.duration = 0.6;
    transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionDefault];
    
    //动画类型，一下是系统API的介绍
    /* The name of the transition. Current legal transition types include
     * `fade', `moveIn', `push' and `reveal'. Defaults to `fade'. */
    transition.type = @&quot;&quot;;

    /*私有API
     cube                   立方体效果
     pageCurl               向上翻一页
     pageUnCurl             向下翻一页
     rippleEffect           水滴波动效果
     suckEffect             变成小布块飞走的感觉
     oglFlip                上下翻转
     cameraIrisHollowClose  相机镜头关闭效果
     cameraIrisHollowOpen   相机镜头打开效果
     */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最后push或present页面就可以完成动画&lt;/p&gt;

&lt;h3 id=&quot;2非交互式转场动画&quot;&gt;2.非交互式转场动画&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1.需要当前的navigationController遵循&lt;UINavigationControllerDelegate&gt;并实现其代理方法&lt;/UINavigationControllerDelegate&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//可以在此代理方法中判断当前是push还是pop
-  (nullable id &amp;lt;UIViewControllerAnimatedTransitioning&amp;gt;)navigationController:(UINavigationController *)navigationController
                                   animationControllerForOperation:(UINavigationControllerOperation)operation
                                                fromViewController:(UIViewController *)fromVC
                                                  toViewController:(UIViewController *)toVC 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;2.我们需要在代理方法中返回一个UIViewControllerAnimatedTransitioning对象，于是我们创建一个类继承自NSObject，遵循&lt;UIViewControllerAnimatedTransitioning&gt;协议，并实现其代理方法
代理方法主要有以下2个&lt;/UIViewControllerAnimatedTransitioning&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// This is used for percent driven interactive transitions, as well as for
// container controllers that have companion animations that might need to
// synchronize with the main animation.
//返回动画的时长
- (NSTimeInterval)transitionDuration:(nullable id &amp;lt;UIViewControllerContextTransitioning&amp;gt;)transitionContext;

// This method can only  be a nop if the transition is interactive and not a percentDriven interactive transition.
//实现具体的动画
- (void)animateTransition:(id &amp;lt;UIViewControllerContextTransitioning&amp;gt;)transitionContext;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//转场过渡的容器view
UIView *containerView = [transitionContext containerView];
//FromVC
UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
UIView *fromView = fromViewController.view;

//ToVC
UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
UIView *toView = toViewController.view;

NSInteger toVCCount = [toViewController.navigationController.viewControllers indexOfObject:toViewController];
NSInteger fromVCCount = [fromViewController.navigationController.viewControllers indexOfObject:fromViewController];
if (toVCCount &amp;gt; fromVCCount) {
   //push
    [containerView addSubview:fromView];
    [containerView addSubview:toView];
}
else{
  //pop
    [containerView addSubview:toView];
    [containerView addSubview:fromView];
}

[UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
        //具体的动画实现

  } completion:^(BOOL finished) {
        BOOL wasCancelled = [transitionContext transitionWasCancelled];
        //设置transitionContext通知系统动画执行完毕
        [transitionContext completeTransition:!wasCancelled];
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;实现酷狗的转场动画&quot;&gt;实现酷狗的转场动画&lt;/h5&gt;
&lt;p&gt;*分别创建两个类继承自NSObject，遵循&lt;UIViewControllerAnimatedTransitioning&gt;协议，来实现push和pop的动画效果*&lt;/UIViewControllerAnimatedTransitioning&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.push动画,将将push的view做仿射变换&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)animateTransition:(id&amp;lt;UIViewControllerContextTransitioning&amp;gt;)transitionContext;

//转场过渡的容器view
UIView *containerView = [transitionContext containerView];
//ToVC
UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
UIView *toView = toViewController.view;
[containerView addSubview:toView];

//将toView绕原点旋转45度
toView.transform = 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;2.pop动画同理&lt;/li&gt;
  &lt;li&gt;3.交互式转场动画&lt;/li&gt;
&lt;/ul&gt;
&lt;UINavigationControllerDelegate&gt;实现其代理方法

```
- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController
```
实现这个方法，系统转场时，就会知道当前是否有交互式的转场，有便执行交互转场，无则执行普通自定义的转场动画
```UIPercentDrivenInteractiveTransition```类是系统定义的，他遵循```UIViewControllerInteractiveTransitioning```协议
此类提供了了以下方法

```
// These methods should be called by the gesture recognizer or some other logic
// to drive the interaction. This style of interaction controller should only be
// used with an animator that implements a CA style transition in the animator's
// animateTransition: method. If this type of interaction controller is
// specified, the animateTransition: method must ensure to call the
// UIViewControllerTransitionParameters completeTransition: method. The other
// interactive methods on UIViewControllerContextTransitioning should NOT be
// called. If there is an interruptible animator, these methods will either scrub or continue 
// the transition in the forward or reverse directions.

- (void)updateInteractiveTransition:(CGFloat)percentComplete;
- (void)cancelInteractiveTransition;
- (void)finishInteractiveTransition;
```
根据pop时传递的手势信息来计算滑动百分比，从而完成交互动画和取消动画


&lt;/UIViewControllerAnimatedTransitioning&gt;&lt;/UIViewControllerInteractiveTransitioning&gt;&lt;/UINavigationControllerDelegate&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">1. 简单push动画和present动画 [self.navigationController.view.layer addAnimation:[self pushAnimation] forKey:@&quot;&quot;]; [self.navigationController pushViewController:[] animated:NO]; [self.view.window.layer addAnimation:[self presentAnimation] forKey:nil]; [self presentViewController:second animated:NO completion:nil]; //系统的API - (void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key; 自定义push动画，然后在push时添加到navigationController中 CATransition -&amp;gt; CAAnimation -&amp;gt; NSObject CATransition *transition = [CATransition animation]; transition.duration = 0.6; transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionDefault]; //动画类型，一下是系统API的介绍 /* The name of the transition. Current legal transition types include * `fade', `moveIn', `push' and `reveal'. Defaults to `fade'. */ transition.type = @&quot;&quot;; /*私有API cube 立方体效果 pageCurl 向上翻一页 pageUnCurl 向下翻一页 rippleEffect 水滴波动效果 suckEffect 变成小布块飞走的感觉 oglFlip 上下翻转 cameraIrisHollowClose 相机镜头关闭效果 cameraIrisHollowOpen 相机镜头打开效果 */ 最后push或present页面就可以完成动画 2.非交互式转场动画 1.需要当前的navigationController遵循并实现其代理方法 //可以在此代理方法中判断当前是push还是pop - (nullable id &amp;lt;UIViewControllerAnimatedTransitioning&amp;gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC 2.我们需要在代理方法中返回一个UIViewControllerAnimatedTransitioning对象，于是我们创建一个类继承自NSObject，遵循协议，并实现其代理方法 代理方法主要有以下2个 // This is used for percent driven interactive transitions, as well as for // container controllers that have companion animations that might need to // synchronize with the main animation. //返回动画的时长 - (NSTimeInterval)transitionDuration:(nullable id &amp;lt;UIViewControllerContextTransitioning&amp;gt;)transitionContext; // This method can only be a nop if the transition is interactive and not a percentDriven interactive transition. //实现具体的动画 - (void)animateTransition:(id &amp;lt;UIViewControllerContextTransitioning&amp;gt;)transitionContext; //转场过渡的容器view UIView *containerView = [transitionContext containerView]; //FromVC UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIView *fromView = fromViewController.view; //ToVC UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIView *toView = toViewController.view; NSInteger toVCCount = [toViewController.navigationController.viewControllers indexOfObject:toViewController]; NSInteger fromVCCount = [fromViewController.navigationController.viewControllers indexOfObject:fromViewController]; if (toVCCount &amp;gt; fromVCCount) { //push [containerView addSubview:fromView]; [containerView addSubview:toView]; } else{ //pop [containerView addSubview:toView]; [containerView addSubview:fromView]; } [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{ //具体的动画实现 } completion:^(BOOL finished) { BOOL wasCancelled = [transitionContext transitionWasCancelled]; //设置transitionContext通知系统动画执行完毕 [transitionContext completeTransition:!wasCancelled]; }]; 实现酷狗的转场动画 *分别创建两个类继承自NSObject，遵循协议，来实现push和pop的动画效果* 1.push动画,将将push的view做仿射变换 - (void)animateTransition:(id&amp;lt;UIViewControllerContextTransitioning&amp;gt;)transitionContext; //转场过渡的容器view UIView *containerView = [transitionContext containerView]; //ToVC UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIView *toView = toViewController.view; [containerView addSubview:toView]; //将toView绕原点旋转45度 toView.transform = 2.pop动画同理 3.交互式转场动画 实现其代理方法 ``` - (nullable id )navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id ) animationController ``` 实现这个方法，系统转场时，就会知道当前是否有交互式的转场，有便执行交互转场，无则执行普通自定义的转场动画 ```UIPercentDrivenInteractiveTransition```类是系统定义的，他遵循```UIViewControllerInteractiveTransitioning```协议 此类提供了了以下方法 ``` // These methods should be called by the gesture recognizer or some other logic // to drive the interaction. This style of interaction controller should only be // used with an animator that implements a CA style transition in the animator's // animateTransition: method. If this type of interaction controller is // specified, the animateTransition: method must ensure to call the // UIViewControllerTransitionParameters completeTransition: method. The other // interactive methods on UIViewControllerContextTransitioning should NOT be // called. If there is an interruptible animator, these methods will either scrub or continue // the transition in the forward or reverse directions. - (void)updateInteractiveTransition:(CGFloat)percentComplete; - (void)cancelInteractiveTransition; - (void)finishInteractiveTransition; ``` 根据pop时传递的手势信息来计算滑动百分比，从而完成交互动画和取消动画</summary></entry><entry><title type="html">Git使用记录</title><link href="http://localhost:4000/Git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/" rel="alternate" type="text/html" title="Git使用记录" /><published>2018-03-03T00:00:00+08:00</published><updated>2018-03-03T00:00:00+08:00</updated><id>http://localhost:4000/Git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95</id><content type="html" xml:base="http://localhost:4000/Git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/">&lt;h4 id=&quot;git创建提交&quot;&gt;Git创建提交&lt;/h4&gt;

&lt;p&gt;创建新仓库
&lt;code class=&quot;highlighter-rouge&quot;&gt;git init&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;git add &amp;lt;filename&amp;gt;&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git add *&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;提交文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m &quot;commit info&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加远程仓库
&lt;code class=&quot;highlighter-rouge&quot;&gt;git remote add origin &amp;lt;server&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;提交到远程仓库
&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;git分支&quot;&gt;Git分支&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创建并切换到Dev分支&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b Dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;切换回主分支:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout master&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;删除Dev分支&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch -d Dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;拉取远程Dev分支&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git fetch origin Dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;拉取远程dev分支，并创建本地dev分支&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b dev origin/dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把某个分支的内容拉取到本地&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull origin Dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看分支&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;git-tag&quot;&gt;Git Tag&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;tag是git版本库的一个标记，指向某个commit的指针
tag主要用于发布版本的管理，一个版本发布之后，我们可以为git打上 v.1.0.1 v.1.0.2 …这样的标签&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看标签&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git tag&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建本地Tag&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git tag &amp;lt;tagName&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建Tag到远程仓库&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin &amp;lt;tagName&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin --tags&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;本地 tag 的删除：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git tag -d &amp;lt;tagName&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;远程 tag 的删除：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin :&amp;lt;tagName&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;版本回退&quot;&gt;版本回退&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交ID ，上一个版本就是HEAD\^，上上一个版本就是HEAD\^\^，当然往上100个版本写100个\^比较容易数不过来，所以写成HEAD~100&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回退到上一个版本
&lt;code class=&quot;highlighter-rouge&quot;&gt;git reset --hard HEAD^&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt;查看版本库的状态&lt;/p&gt;

&lt;p&gt;Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向旧的版本&lt;/p&gt;

&lt;p&gt;Git提供了一个命令&lt;code class=&quot;highlighter-rouge&quot;&gt;git reflog&lt;/code&gt;用来记录你的每一次命令&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;git更新与合并&quot;&gt;Git更新与合并&lt;/h4&gt;
&lt;p&gt;更新你的本地仓库至最新改动
git pull&lt;/p&gt;</content><author><name></name></author><category term="Git" /><summary type="html">Git创建提交 创建新仓库 git init 添加文件 git add &amp;lt;filename&amp;gt; git add * 提交文件 git commit -m &quot;commit info&quot; 添加远程仓库 git remote add origin &amp;lt;server&amp;gt; 提交到远程仓库 git push origin &amp;lt;branch name&amp;gt;</summary></entry><entry><title type="html">iOS直播项目总结</title><link href="http://localhost:4000/iOS%E7%9B%B4%E6%92%AD%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="iOS直播项目总结" /><published>2018-01-07T00:00:00+08:00</published><updated>2018-01-07T00:00:00+08:00</updated><id>http://localhost:4000/iOS%E7%9B%B4%E6%92%AD%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/iOS%E7%9B%B4%E6%92%AD%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">&lt;h4 id=&quot;直播流媒体介绍&quot;&gt;直播流媒体介绍&lt;/h4&gt;

&lt;p&gt;直播，音乐播放demo&lt;/p&gt;

&lt;p&gt;https://github.com/AndreHu88/iOS_Live&lt;/p&gt;

&lt;p&gt;视频流传输使用的是RTMP协议（类似于socket，基于TCP）
RTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于TCP&lt;/p&gt;

&lt;p&gt;流媒体开发:网络层(socket或st)负责传输，协议层(rtmp或hls)负责网络打包，封装层(flv、ts)负责编解码数据的封装，编码层(h.264和aac)负责图像，音频压缩。
用于对象,视频,音频的传输.这个协议建立在TCP协议或者轮询HTTP协议之上.&lt;/p&gt;

&lt;p&gt;HLS:由Apple公司定义的用于实时流传输的协议,HLS基于HTTP协议实现，传输内容包括两部分，一是M3U8描述文件，二是TS媒体文件。可实现流媒体的直播和点播，主要应用在iOS系统
HLS与RTMP对比:HLS主要是延时比较大，RTMP主要优势在于延时低&lt;/p&gt;

&lt;p&gt;下图是直播的完整图解
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4499332-a5920ba5063faae1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;播放网络视频需要以下几步依赖ffmpeg框架&quot;&gt;播放网络视频需要以下几步（依赖FFmpeg框架）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;将数据解协议&lt;/li&gt;
  &lt;li&gt;解封装&lt;/li&gt;
  &lt;li&gt;解码音视频&lt;/li&gt;
  &lt;li&gt;音视频同步&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;播放本地视频不需要解协议直接解封装&quot;&gt;播放本地视频不需要解协议，直接解封装&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;解协议&lt;/strong&gt;
解协议就是将流媒体协议上的数据解析为相应的封装格式数据，流媒体一般是RTMP协议传输，这些协议在传输音视频数据的同时也可以传输一些指令数据（播放，停止，暂停，网络状态的描述） ，解协议会去掉信令数据，只保留音视频数据。采用RTMP协议通过解协议后，输入FLV的流&lt;/p&gt;

    &lt;p&gt;FFMpeg会根据相关协议的特性，本机与服务器建立连接，获取流数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;解封装&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;将封装的视频数据分离成音频和视频编码数据，常见的封装的格式有MP4，MKV, RMVB, FLV, AVI等。它的作用就是将已压缩的视频数据和音频数据按照一定的格式放在一起。FLV格式经过解封装后，可以得到H.264的视频编码数据和aac的音频编码数据，一般称为“packet”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;解码音视频&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;解码就是将音视频压缩编码数据解码成非压缩的音视频的原始数据，解码是最复杂最重要的一个环节，通过解码压缩的视频数据被输出成非压缩的颜色数据。目前常用的音频编码方式是aac,mp3,视频编码格式是H.264,H.265。分析源数据的音视频信息，分别设置对应的音频解码器，视频编码器。对packet分别进行解码后，音频解码获得的数据是PCM（Pulse Code Modulation，脉冲编码调制）采样数据，一般称为“sample”。视频解码获得的数据是一幅YUV或RGB图像数据，一般称为“picture”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;音视频同步&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;音视频解码是两个独立的线程，获取到的音视频是分开的。理想情况下，音视频按照自己的固有频率渲染输出能达到音视频同步的效果，但是在现实中，断网、弱网、丢帧、缓冲、音视频不同的解码耗时等情况都会妨碍实现同步，很难达到预期效果。 通过音视频同步调整后，将同步解码出来的音频，视频数据，同步给显卡和声卡播放出来。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;videotoolboxframework硬编码&quot;&gt;VideoToolbox.framework(硬编码)&lt;/h4&gt;
&lt;p&gt;videoToolbox是苹果的一个硬解码的框架，提供实现压缩，解压缩服务，并存储在缓冲区corevideo像素栅格图像格式之中。这些服务以会话对象的形式提供（压缩、解压，和像素传输），应用程序不需要直接访问硬件编码器和解码器相关内容，硬件编解码这块的质量有一定保证，可以优先使用硬编解码，和软解码FFmpeg可以互补&lt;/p&gt;

&lt;h5 id=&quot;h264的详解&quot;&gt;H.264的详解&lt;/h5&gt;
&lt;p&gt;这篇blog详解:http://www.samirchen.com/video-concept/&lt;/p&gt;

&lt;h5 id=&quot;编码h264&quot;&gt;编码H.264&lt;/h5&gt;
&lt;p&gt;1.初始化VideoToolbox&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setupVideoToolbox{
    
    dispatch_sync(_encodeQueue, ^{
        
        [self setupFileHandle];
        
        int width = 720, height = 1280;
        OSStatus status = VTCompressionSessionCreate(NULL, width, height, kCMVideoCodecType_H264, NULL, NULL, NULL, encodingComplectionCallback, (__bridge void *)(self), &amp;amp;_encodingSession);
        DLog(@&quot;status code is %d&quot;,(int)status);
        if (status != 0) {
            DLog(@&quot;create H264 session error&quot;);
            return ;
        }
        
        //设置实时编码，避免延迟
        VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_RealTime, kCFBooleanTrue);
        VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_ProfileLevel, kVTProfileLevel_H264_Baseline_AutoLevel);
        
        //设置关键帧间隔（）关键字间隔越小越清晰，数值越大压缩率越高
        int frameInterval = 1;
        CFNumberRef frameIntervalRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &amp;amp;frameInterval);
        VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_MaxKeyFrameInterval, frameIntervalRef);
        
        //设置期望帧率
        int fps = 30;
        CFNumberRef fpsRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &amp;amp;fps);
        VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_ExpectedFrameRate, fpsRef);
        
        //设置码率，均值，单位是byte
        int bitRate = width * height * 3 * 4 * 8;
        CFNumberRef bitRateRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;amp;bitRate);
        VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_AverageBitRate, bitRateRef);
        
        //设置码率上限，单位是bps,如果不设置默认会以很低的码率编码，导致编码出来的视频很模糊
        int bitRateMax = width * height * 3 * 4;
        CFNumberRef bitRateMaxRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;amp;bitRateMax);
        VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_DataRateLimits, bitRateMaxRef);
        
        //准备编码
        VTCompressionSessionPrepareToEncodeFrames(_encodingSession);
        
    });
}

- (void)setupFileHandle{
    
    //创建文件，初始化fileHandle;
    NSString *file = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;test.h264&quot;];
    [[NSFileManager defaultManager] removeItemAtPath:file error:nil];
    [[NSFileManager defaultManager] createFileAtPath:file contents:nil attributes:nil];
    _fileHandle = [NSFileHandle fileHandleForWritingAtPath:file];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;2.sampleBuffer回调处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)videoEncodeWithSampleBuffer:(CMSampleBufferRef)sampleBuffer{
    
    dispatch_sync(_encodeQueue, ^{
        
        // CVPixelBufferRef 编码前图像数据结构
        // 利用给定的接口函数CMSampleBufferGetImageBuffer从中提取出CVPixelBufferRef
        CVImageBufferRef imageBuffer = (CVImageBufferRef)CMSampleBufferGetImageBuffer(sampleBuffer);
        // 帧时间 如果不设置导致时间轴过长
        CMTime presentationTimeStamp = CMTimeMake(_frameID++, 1000);
        //flags 0 表示同步解码
        VTEncodeInfoFlags flags;
        OSStatus status = VTCompressionSessionEncodeFrame(_encodingSession, imageBuffer, presentationTimeStamp, kCMTimeInvalid, NULL, NULL, &amp;amp;flags);
        DLog(@&quot;status code is %d&quot;,(int)status);
        if (status == noErr) {
            DLog(@&quot;H264 VTCompressionSessionEncodeFrame success&quot;);
        }
        else{
            DLog(@&quot;H264: VTCompressionSessionEncodeFrame failed with %d&quot;, (int)status);
            if (!_encodingSession) return;
            VTCompressionSessionInvalidate(_encodingSession);
            //释放资源
            CFRelease(_encodingSession);
            _encodingSession = NULL;
        }
    });
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.对VideoToolbox的编码回调&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//每压缩一次都异步的调用此方法
void encodingComplectionCallback(void * CM_NULLABLE outputCallbackRefCon,
                               void * CM_NULLABLE sourceFrameRefCon,
                               OSStatus status,
                               VTEncodeInfoFlags infoFlags,
                               CM_NULLABLE CMSampleBufferRef sampleBuffer ){

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;音视频同步详解&quot;&gt;音视频同步详解&lt;/h5&gt;
&lt;p&gt;播放速度标准量有以下三种&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;将视频同步到音频上&lt;/strong&gt;，就是以音频的播放速度为基准来同步视频。视频比音频播放慢了，加快其播放速度；快了，则延迟播放。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;将音频同步到视频上&lt;/strong&gt;，就是以视频的播放速度为基准来同步音频。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;将视频和音频同步外部的时钟上&lt;/strong&gt;，选择一个外部时钟为基准，视频和音频的播放速度都以该时钟为标准&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;视频和音频的同步过程是一个你等我赶的过程，快了则等待，慢了就加快速度。这就需要一个量来判断（和选择基准比较），到底是播放的快了还是慢了，或者正以同步的速度播放。在音视频的包中都含有DTS(decode time stamp)，告诉解码器packet的解码顺序 和 PTS(presentation time stamp)，从packet解码出来的数据的显示顺序。&lt;/p&gt;

&lt;p&gt;对于音频来说，DTS和PTS是相同的，也就是解码顺序和显示顺序一致
视频的编码比音频复杂，DTS和PTS会不同。视频在编码后会得到三种不同的帧&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;I帧  关键帧&lt;/strong&gt;，包含了一帧的完整数据，解码时只需要本帧的数据，不需要参考其他帧。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;P帧 P是向前搜索&lt;/strong&gt;，该帧的数据不完全的，解码时需要参考其前一帧的数据。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;B帧 B是双向搜索&lt;/strong&gt;，解码这种类型的帧是最复杂，不但需要参考其一帧的数据，还需要其后一帧的数据。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">直播流媒体介绍 直播，音乐播放demo https://github.com/AndreHu88/iOS_Live 视频流传输使用的是RTMP协议（类似于socket，基于TCP） RTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于TCP 流媒体开发:网络层(socket或st)负责传输，协议层(rtmp或hls)负责网络打包，封装层(flv、ts)负责编解码数据的封装，编码层(h.264和aac)负责图像，音频压缩。 用于对象,视频,音频的传输.这个协议建立在TCP协议或者轮询HTTP协议之上. HLS:由Apple公司定义的用于实时流传输的协议,HLS基于HTTP协议实现，传输内容包括两部分，一是M3U8描述文件，二是TS媒体文件。可实现流媒体的直播和点播，主要应用在iOS系统 HLS与RTMP对比:HLS主要是延时比较大，RTMP主要优势在于延时低 下图是直播的完整图解 播放网络视频需要以下几步（依赖FFmpeg框架） 将数据解协议 解封装 解码音视频 音视频同步 播放本地视频不需要解协议，直接解封装 解协议 解协议就是将流媒体协议上的数据解析为相应的封装格式数据，流媒体一般是RTMP协议传输，这些协议在传输音视频数据的同时也可以传输一些指令数据（播放，停止，暂停，网络状态的描述） ，解协议会去掉信令数据，只保留音视频数据。采用RTMP协议通过解协议后，输入FLV的流 FFMpeg会根据相关协议的特性，本机与服务器建立连接，获取流数据 解封装 将封装的视频数据分离成音频和视频编码数据，常见的封装的格式有MP4，MKV, RMVB, FLV, AVI等。它的作用就是将已压缩的视频数据和音频数据按照一定的格式放在一起。FLV格式经过解封装后，可以得到H.264的视频编码数据和aac的音频编码数据，一般称为“packet” 解码音视频 解码就是将音视频压缩编码数据解码成非压缩的音视频的原始数据，解码是最复杂最重要的一个环节，通过解码压缩的视频数据被输出成非压缩的颜色数据。目前常用的音频编码方式是aac,mp3,视频编码格式是H.264,H.265。分析源数据的音视频信息，分别设置对应的音频解码器，视频编码器。对packet分别进行解码后，音频解码获得的数据是PCM（Pulse Code Modulation，脉冲编码调制）采样数据，一般称为“sample”。视频解码获得的数据是一幅YUV或RGB图像数据，一般称为“picture” 音视频同步 音视频解码是两个独立的线程，获取到的音视频是分开的。理想情况下，音视频按照自己的固有频率渲染输出能达到音视频同步的效果，但是在现实中，断网、弱网、丢帧、缓冲、音视频不同的解码耗时等情况都会妨碍实现同步，很难达到预期效果。 通过音视频同步调整后，将同步解码出来的音频，视频数据，同步给显卡和声卡播放出来。 VideoToolbox.framework(硬编码) videoToolbox是苹果的一个硬解码的框架，提供实现压缩，解压缩服务，并存储在缓冲区corevideo像素栅格图像格式之中。这些服务以会话对象的形式提供（压缩、解压，和像素传输），应用程序不需要直接访问硬件编码器和解码器相关内容，硬件编解码这块的质量有一定保证，可以优先使用硬编解码，和软解码FFmpeg可以互补 H.264的详解 这篇blog详解:http://www.samirchen.com/video-concept/ 编码H.264 1.初始化VideoToolbox - (void)setupVideoToolbox{ dispatch_sync(_encodeQueue, ^{ [self setupFileHandle]; int width = 720, height = 1280; OSStatus status = VTCompressionSessionCreate(NULL, width, height, kCMVideoCodecType_H264, NULL, NULL, NULL, encodingComplectionCallback, (__bridge void *)(self), &amp;amp;_encodingSession); DLog(@&quot;status code is %d&quot;,(int)status); if (status != 0) { DLog(@&quot;create H264 session error&quot;); return ; } //设置实时编码，避免延迟 VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_RealTime, kCFBooleanTrue); VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_ProfileLevel, kVTProfileLevel_H264_Baseline_AutoLevel); //设置关键帧间隔（）关键字间隔越小越清晰，数值越大压缩率越高 int frameInterval = 1; CFNumberRef frameIntervalRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &amp;amp;frameInterval); VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_MaxKeyFrameInterval, frameIntervalRef); //设置期望帧率 int fps = 30; CFNumberRef fpsRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &amp;amp;fps); VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_ExpectedFrameRate, fpsRef); //设置码率，均值，单位是byte int bitRate = width * height * 3 * 4 * 8; CFNumberRef bitRateRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;amp;bitRate); VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_AverageBitRate, bitRateRef); //设置码率上限，单位是bps,如果不设置默认会以很低的码率编码，导致编码出来的视频很模糊 int bitRateMax = width * height * 3 * 4; CFNumberRef bitRateMaxRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;amp;bitRateMax); VTSessionSetProperty(_encodingSession, kVTCompressionPropertyKey_DataRateLimits, bitRateMaxRef); //准备编码 VTCompressionSessionPrepareToEncodeFrames(_encodingSession); }); } - (void)setupFileHandle{ //创建文件，初始化fileHandle; NSString *file = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;test.h264&quot;]; [[NSFileManager defaultManager] removeItemAtPath:file error:nil]; [[NSFileManager defaultManager] createFileAtPath:file contents:nil attributes:nil]; _fileHandle = [NSFileHandle fileHandleForWritingAtPath:file]; } 2.sampleBuffer回调处理 - (void)videoEncodeWithSampleBuffer:(CMSampleBufferRef)sampleBuffer{ dispatch_sync(_encodeQueue, ^{ // CVPixelBufferRef 编码前图像数据结构 // 利用给定的接口函数CMSampleBufferGetImageBuffer从中提取出CVPixelBufferRef CVImageBufferRef imageBuffer = (CVImageBufferRef)CMSampleBufferGetImageBuffer(sampleBuffer); // 帧时间 如果不设置导致时间轴过长 CMTime presentationTimeStamp = CMTimeMake(_frameID++, 1000); //flags 0 表示同步解码 VTEncodeInfoFlags flags; OSStatus status = VTCompressionSessionEncodeFrame(_encodingSession, imageBuffer, presentationTimeStamp, kCMTimeInvalid, NULL, NULL, &amp;amp;flags); DLog(@&quot;status code is %d&quot;,(int)status); if (status == noErr) { DLog(@&quot;H264 VTCompressionSessionEncodeFrame success&quot;); } else{ DLog(@&quot;H264: VTCompressionSessionEncodeFrame failed with %d&quot;, (int)status); if (!_encodingSession) return; VTCompressionSessionInvalidate(_encodingSession); //释放资源 CFRelease(_encodingSession); _encodingSession = NULL; } }); } 3.对VideoToolbox的编码回调 //每压缩一次都异步的调用此方法 void encodingComplectionCallback(void * CM_NULLABLE outputCallbackRefCon, void * CM_NULLABLE sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags, CM_NULLABLE CMSampleBufferRef sampleBuffer ){ } 音视频同步详解 播放速度标准量有以下三种 将视频同步到音频上，就是以音频的播放速度为基准来同步视频。视频比音频播放慢了，加快其播放速度；快了，则延迟播放。 将音频同步到视频上，就是以视频的播放速度为基准来同步音频。 将视频和音频同步外部的时钟上，选择一个外部时钟为基准，视频和音频的播放速度都以该时钟为标准 视频和音频的同步过程是一个你等我赶的过程，快了则等待，慢了就加快速度。这就需要一个量来判断（和选择基准比较），到底是播放的快了还是慢了，或者正以同步的速度播放。在音视频的包中都含有DTS(decode time stamp)，告诉解码器packet的解码顺序 和 PTS(presentation time stamp)，从packet解码出来的数据的显示顺序。 对于音频来说，DTS和PTS是相同的，也就是解码顺序和显示顺序一致 视频的编码比音频复杂，DTS和PTS会不同。视频在编码后会得到三种不同的帧 I帧 关键帧，包含了一帧的完整数据，解码时只需要本帧的数据，不需要参考其他帧。 P帧 P是向前搜索，该帧的数据不完全的，解码时需要参考其前一帧的数据。 B帧 B是双向搜索，解码这种类型的帧是最复杂，不但需要参考其一帧的数据，还需要其后一帧的数据。</summary></entry></feed>