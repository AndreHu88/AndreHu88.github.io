<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-18T23:05:07+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">风车大战骑士</title><subtitle>生活不止眼前的苟且，还有诗和远方</subtitle><entry><title type="html">唐朝笔记</title><link href="http://localhost:4000/%E5%94%90%E6%9C%9D%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="唐朝笔记" /><published>2020-09-20T00:00:00+08:00</published><updated>2020-09-20T00:00:00+08:00</updated><id>http://localhost:4000/%E5%94%90%E6%9C%9D%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/%E5%94%90%E6%9C%9D%E7%AC%94%E8%AE%B0/">&lt;h3 id=&quot;金融读书笔记&quot;&gt;金融读书笔记&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-1482a160b3ccdf4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;利润表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-56ec40508576a413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;投资相关资产&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-1853f11fb16b261d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;操纵手法&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-c2b66336c3bc9002.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;操纵痕迹&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-03baed702f565c25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;现金流肖像&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-620d6ca4173c4bf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;现金流速度&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-e1d18d704154ad43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;现金流量表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-997912976c02a8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;生产相关资产&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-0176bcc5d061b023.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;经营相关资产&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-df85fc4ee247cca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;货币资金&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-7e0d27d8c00121ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;速度利润表&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="金融学习" /><summary type="html">金融读书笔记</summary></entry><entry><title type="html">APM总结</title><link href="http://localhost:4000/APM%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="APM总结" /><published>2020-06-20T00:00:00+08:00</published><updated>2020-06-20T00:00:00+08:00</updated><id>http://localhost:4000/APM%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/APM%E6%80%BB%E7%BB%93/">&lt;h5 id=&quot;apm监控卡顿并上报有两种方案&quot;&gt;APM监控卡顿并上报有两种方案：&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;监听Runloop状态回调， 子线程ping主线程
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if (currentMode-&amp;gt;_observerMask &amp;amp; kCFRunLoopEntry )
        // 通知 Observers: RunLoop 即将进入 loop
        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    // 进入loop
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开启do while 循环保活线程，通知Observers, Runloop触发timer回调，然后执行被加入的Block
```
  if (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeTimers)
     //  通知 Observers: RunLoop 即将触发 Timer 回调
     __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);&lt;/p&gt;

    &lt;p&gt;if (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeSources)
     //  通知 Observers: RunLoop 即将触发 Source 回调
     __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);
 // 执行被加入的block
 __CFRunLoopDoBlocks(rl, rlm);&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3. runloop触发source0的回调，如果source1是ready状态，会跳转到handle_msg去处理消息, 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (MACH_PORT_NULL != dispatchPort &amp;amp;&amp;amp; !didDispatchPortLastTime) {
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
    msg = (mach_msg_header_t *)msg_buffer;
    
    if (__CFRunLoopServiceMachPort(dispatchPort, &amp;amp;msg, sizeof(msg_buffer), &amp;amp;livePort, 0, &amp;amp;voucherState, NULL)) {
        goto handle_msg;
    }
#elif DEPLOYMENT_TARGET_WINDOWS
    if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;amp;dispatchPort, 0, 0, &amp;amp;livePort, NULL)) {
        goto handle_msg;
    }
#endif
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4. 回调触发后，通知Observer进入休眠状态
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&amp;gt;termTSR);
 // 通知 Observers: RunLoop 的线程即将进入休眠(sleep)
 if (!poll &amp;amp;&amp;amp; (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);
     __CFRunLoopSetSleeping(rl);&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5. 休眠后，等待mach_port消息，以便再次唤醒
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do {
    if (kCFUseCollectableAllocator) {
        // objc_clear_stack(0);
        // &amp;lt;rdar://problem/16393959&amp;gt;
        memset(msg_buffer, 0, sizeof(msg_buffer));
    }
    msg = (mach_msg_header_t *)msg_buffer;
    
    __CFRunLoopServiceMachPort(waitSet, &amp;amp;msg, sizeof(msg_buffer), &amp;amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;amp;voucherState, &amp;amp;voucherCopy);
    
    if (modeQueuePort != MACH_PORT_NULL &amp;amp;&amp;amp; livePort == modeQueuePort) {
        // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.
        while (_dispatch_runloop_root_queue_perform_4CF(rlm-&amp;gt;_queue));
        if (rlm-&amp;gt;_timerFired) {
            // Leave livePort as the queue port, and service timers below
            rlm-&amp;gt;_timerFired = false;
            break;
        } else {
            if (msg &amp;amp;&amp;amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);
        }
    } else {
        // Go ahead and leave the inner loop.
        break;
    }
} while (1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
6. 唤醒时通知Observer， Runloop的线程刚刚被唤醒了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 通知 Observers: RunLoop 的线程刚刚被唤醒了
if (!poll &amp;amp;&amp;amp; (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);
    // 处理消息
    handle_msg:;
    __CFRunLoopSetIgnoreWakeUps(rl);  ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Runloop唤醒后，处理唤醒时收到的消息&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;///如果是Timer处理回调
///如果是dispatch，处理block
///如果是source1， 处理事件

 #if USE_MK_TIMER_TOO
         // 如果一个 Timer 到时间了，触发这个Timer的回调
         else if (rlm-&amp;gt;_timerPort != MACH_PORT_NULL &amp;amp;&amp;amp; livePort == rlm-&amp;gt;_timerPort) {
             CFRUNLOOP_WAKEUP_FOR_TIMER();
             // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be 'too early' for the next timer, and no timers are handled.
             // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754
             if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
                 // Re-arm the next timer
                 __CFArmNextTimerInMode(rlm, rl);
             }
         }
 #endif
         //  如果有dispatch到main_queue的block，执行block
         else if (livePort == dispatchPort) {
             CFRUNLOOP_WAKEUP_FOR_DISPATCH();
             __CFRunLoopModeUnlock(rlm);
             __CFRunLoopUnlock(rl);
             _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);
 #if DEPLOYMENT_TARGET_WINDOWS
             void *msg = 0;
 #endif
             __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
             _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);
             __CFRunLoopLock(rl);
             __CFRunLoopModeLock(rlm);
             sourceHandledThisLoop = true;
             didDispatchPortLastTime = true;
         }
         // 如果一个 Source1 (基于port) 发出事件了，处理这个事件
         else {
             CFRUNLOOP_WAKEUP_FOR_SOURCE();
             
             // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.
             voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);

             CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);
             if (rls) {
 #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
         mach_msg_header_t *reply = NULL;
         sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&amp;gt;msgh_size, &amp;amp;reply) || sourceHandledThisLoop;
         if (NULL != reply) {
             (void)mach_msg(reply, MACH_SEND_MSG, reply-&amp;gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
             CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);
         }
 #elif DEPLOYMENT_TARGET_WINDOWS
                 sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;
 #endif

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;根据当前runloop状态判断是否需要进入下一个loop, 当被外部强制停止或者loop超时，就不继续下一个loop,  否则进入下一个loop&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
    if (sourceHandledThisLoop &amp;amp;&amp;amp; stopAfterHandle) {
        // 进入loop时参数说处理完事件就返回
        retVal = kCFRunLoopRunHandledSource;
        } else if (timeout_context-&amp;gt;termTSR &amp;lt; mach_absolute_time()) {
            // 超出传入参数标记的超时时间了
            retVal = kCFRunLoopRunTimedOut;
    } else if (__CFRunLoopIsStopped(rl)) {
            __CFRunLoopUnsetStopped(rl);
        // 被外部调用者强制停止了
        retVal = kCFRunLoopRunStopped;
    } else if (rlm-&amp;gt;_stopped) {
        rlm-&amp;gt;_stopped = false;
        retVal = kCFRunLoopRunStopped;
    } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {
        // source/timer一个都没有
        retVal = kCFRunLoopRunFinished;
    }

 */

/// Source1是runloop用来处理Mach port传来的系统的事件的，  Source0是用来处理用户事件的
/// 检测runloop，一旦发现在进入睡眠前的KCFRunLoopBeforeSources到唤醒后 KCFRunLoopAfterWaiting的时间过长，说明Runloop卡顿了， 开启一个子线程，不断的去循环检测，如果在n次都超过了预定好的阈值， 认为是卡顿了， 然后进行dump当前的堆栈并上报

/**
 通过 long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)  方法判断是否阻塞主线程，Returns zero on success, or non-zero if the timeout occurred.  返回非0则代表超时阻塞了主线程
 */



//MARK: 子线程ping主线程监听的方式
///开启一个子线程，创建一个初始值为0的信号量， 一个bool标志位，将设置为NO的标志位的任务派发到主线程中去， 子线程休眠阈值到后判断是否被主线程成功，如果没成功认为是主线程卡顿
/*
 
 while (self.isCancelled == NO) {
 
     @autoreleasepool {
         __block BOOL isMainThreadNoRespond = YES;
         
         dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
         
         dispatch_async(dispatch_get_main_queue(), ^{
             isMainThreadNoRespond = NO;
             dispatch_semaphore_signal(semaphore);
         });
         
         [NSThread sleepForTimeInterval:self.threshold];
         
         if (isMainThreadNoRespond) {
             if (self.handlerBlock) {
                 self.handlerBlock(); // 外部在 block 内部 dump 堆栈（下面会讲），数据上报
             }
         }
         
         dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
     }
 }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;启动时间监控&quot;&gt;启动时间监控&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 . pre-main阶段影响因素
/**
 1. 动态库越多，启动越慢
 2. Objc类越好,  函数越多，启动越慢
 3. 可执行文件越大，启动越慢
 4. Objc的load方法越多，启动越慢
 */

/**
    struct thread_basic_info {
        time_value_t    user_time;      /* user run time（用户运行时长） */
        time_value_t    system_time;    /* system run time（系统运行时长） */
        integer_t       cpu_usage;      /* scaled cpu usage percentage（CPU使用率，上限1000） */
        policy_t        policy;         /* scheduling policy in effect（有效调度策略） */
        integer_t       run_state;      /* run state (运行状态，见下) */
        integer_t       flags;          /* various flags (各种各样的标记) */
        integer_t       suspend_count;  /* suspend count for thread（线程挂起次数） */
        integer_t       sleep_time;     /* number of seconds that thread
                                         *  has been sleeping（休眠时间） */
    };
 */

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OOM 超出了内存分配
/// 收到低内存警告不一定会 Crash，因为有6秒钟的系统判断时间，6秒内内存下降了则不会 crash。发生 OOM 也不一定会收到低内存警告
/**
 合理使用autoreleasepool, autoreleasepool对象是在Runloop结束时释放，在ARC下， 如果我们不断的申请内存， 我们需要手动的添加autoreleasepool， 避免短时间内内存猛涨发生OOM
 内存分配:  malloc用的是 malloc_zone_malloc,  calloc用的是malloc_zone_calloc
  在处理图片缩放时，ImageIO占用内存会比直接处理图片缩放小
 */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">APM监控卡顿并上报有两种方案： 监听Runloop状态回调， 子线程ping主线程 if (currentMode-&amp;gt;_observerMask &amp;amp; kCFRunLoopEntry ) // 通知 Observers: RunLoop 即将进入 loop __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); // 进入loop result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); 开启do while 循环保活线程，通知Observers, Runloop触发timer回调，然后执行被加入的Block ``` if (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeTimers) // 通知 Observers: RunLoop 即将触发 Timer 回调 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); if (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeSources) // 通知 Observers: RunLoop 即将触发 Source 回调 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); // 执行被加入的block __CFRunLoopDoBlocks(rl, rlm); 3. runloop触发source0的回调，如果source1是ready状态，会跳转到handle_msg去处理消息, 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息 if (MACH_PORT_NULL != dispatchPort &amp;amp;&amp;amp; !didDispatchPortLastTime) { #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI msg = (mach_msg_header_t *)msg_buffer; if (__CFRunLoopServiceMachPort(dispatchPort, &amp;amp;msg, sizeof(msg_buffer), &amp;amp;livePort, 0, &amp;amp;voucherState, NULL)) { goto handle_msg; } #elif DEPLOYMENT_TARGET_WINDOWS if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;amp;dispatchPort, 0, 0, &amp;amp;livePort, NULL)) { goto handle_msg; } #endif } 4. 回调触发后，通知Observer进入休眠状态 Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&amp;gt;termTSR); // 通知 Observers: RunLoop 的线程即将进入休眠(sleep) if (!poll &amp;amp;&amp;amp; (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); __CFRunLoopSetSleeping(rl); 5. 休眠后，等待mach_port消息，以便再次唤醒 do { if (kCFUseCollectableAllocator) { // objc_clear_stack(0); // &amp;lt;rdar://problem/16393959&amp;gt; memset(msg_buffer, 0, sizeof(msg_buffer)); } msg = (mach_msg_header_t *)msg_buffer; __CFRunLoopServiceMachPort(waitSet, &amp;amp;msg, sizeof(msg_buffer), &amp;amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;amp;voucherState, &amp;amp;voucherCopy); if (modeQueuePort != MACH_PORT_NULL &amp;amp;&amp;amp; livePort == modeQueuePort) { // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer. while (_dispatch_runloop_root_queue_perform_4CF(rlm-&amp;gt;_queue)); if (rlm-&amp;gt;_timerFired) { // Leave livePort as the queue port, and service timers below rlm-&amp;gt;_timerFired = false; break; } else { if (msg &amp;amp;&amp;amp; msg != (mach_msg_header_t *)msg_buffer) free(msg); } } else { // Go ahead and leave the inner loop. break; } } while (1); 6. 唤醒时通知Observer， Runloop的线程刚刚被唤醒了 // 通知 Observers: RunLoop 的线程刚刚被唤醒了 if (!poll &amp;amp;&amp;amp; (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); // 处理消息 handle_msg:; __CFRunLoopSetIgnoreWakeUps(rl); ``` Runloop唤醒后，处理唤醒时收到的消息 ///如果是Timer处理回调 ///如果是dispatch，处理block ///如果是source1， 处理事件 #if USE_MK_TIMER_TOO // 如果一个 Timer 到时间了，触发这个Timer的回调 else if (rlm-&amp;gt;_timerPort != MACH_PORT_NULL &amp;amp;&amp;amp; livePort == rlm-&amp;gt;_timerPort) { CFRUNLOOP_WAKEUP_FOR_TIMER(); // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be 'too early' for the next timer, and no timers are handled. // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754 if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) { // Re-arm the next timer __CFArmNextTimerInMode(rlm, rl); } } #endif // 如果有dispatch到main_queue的block，执行block else if (livePort == dispatchPort) { CFRUNLOOP_WAKEUP_FOR_DISPATCH(); __CFRunLoopModeUnlock(rlm); __CFRunLoopUnlock(rl); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL); #if DEPLOYMENT_TARGET_WINDOWS void *msg = 0; #endif __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL); __CFRunLoopLock(rl); __CFRunLoopModeLock(rlm); sourceHandledThisLoop = true; didDispatchPortLastTime = true; } // 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else { CFRUNLOOP_WAKEUP_FOR_SOURCE(); // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again. voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release); CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort); if (rls) { #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI mach_msg_header_t *reply = NULL; sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&amp;gt;msgh_size, &amp;amp;reply) || sourceHandledThisLoop; if (NULL != reply) { (void)mach_msg(reply, MACH_SEND_MSG, reply-&amp;gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL); CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply); } #elif DEPLOYMENT_TARGET_WINDOWS sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop; #endif 根据当前runloop状态判断是否需要进入下一个loop, 当被外部强制停止或者loop超时，就不继续下一个loop, 否则进入下一个loop /** if (sourceHandledThisLoop &amp;amp;&amp;amp; stopAfterHandle) { // 进入loop时参数说处理完事件就返回 retVal = kCFRunLoopRunHandledSource; } else if (timeout_context-&amp;gt;termTSR &amp;lt; mach_absolute_time()) { // 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; } else if (__CFRunLoopIsStopped(rl)) { __CFRunLoopUnsetStopped(rl); // 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; } else if (rlm-&amp;gt;_stopped) { rlm-&amp;gt;_stopped = false; retVal = kCFRunLoopRunStopped; } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) { // source/timer一个都没有 retVal = kCFRunLoopRunFinished; } */ /// Source1是runloop用来处理Mach port传来的系统的事件的， Source0是用来处理用户事件的 /// 检测runloop，一旦发现在进入睡眠前的KCFRunLoopBeforeSources到唤醒后 KCFRunLoopAfterWaiting的时间过长，说明Runloop卡顿了， 开启一个子线程，不断的去循环检测，如果在n次都超过了预定好的阈值， 认为是卡顿了， 然后进行dump当前的堆栈并上报 /** 通过 long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) 方法判断是否阻塞主线程，Returns zero on success, or non-zero if the timeout occurred. 返回非0则代表超时阻塞了主线程 */ //MARK: 子线程ping主线程监听的方式 ///开启一个子线程，创建一个初始值为0的信号量， 一个bool标志位，将设置为NO的标志位的任务派发到主线程中去， 子线程休眠阈值到后判断是否被主线程成功，如果没成功认为是主线程卡顿 /* while (self.isCancelled == NO) { @autoreleasepool { __block BOOL isMainThreadNoRespond = YES; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_async(dispatch_get_main_queue(), ^{ isMainThreadNoRespond = NO; dispatch_semaphore_signal(semaphore); }); [NSThread sleepForTimeInterval:self.threshold]; if (isMainThreadNoRespond) { if (self.handlerBlock) { self.handlerBlock(); // 外部在 block 内部 dump 堆栈（下面会讲），数据上报 } } dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); } } 启动时间监控 1 . pre-main阶段影响因素 /** 1. 动态库越多，启动越慢 2. Objc类越好, 函数越多，启动越慢 3. 可执行文件越大，启动越慢 4. Objc的load方法越多，启动越慢 */ /** struct thread_basic_info { time_value_t user_time; /* user run time（用户运行时长） */ time_value_t system_time; /* system run time（系统运行时长） */ integer_t cpu_usage; /* scaled cpu usage percentage（CPU使用率，上限1000） */ policy_t policy; /* scheduling policy in effect（有效调度策略） */ integer_t run_state; /* run state (运行状态，见下) */ integer_t flags; /* various flags (各种各样的标记) */ integer_t suspend_count; /* suspend count for thread（线程挂起次数） */ integer_t sleep_time; /* number of seconds that thread * has been sleeping（休眠时间） */ }; */ OOM 超出了内存分配 /// 收到低内存警告不一定会 Crash，因为有6秒钟的系统判断时间，6秒内内存下降了则不会 crash。发生 OOM 也不一定会收到低内存警告 /** 合理使用autoreleasepool, autoreleasepool对象是在Runloop结束时释放，在ARC下， 如果我们不断的申请内存， 我们需要手动的添加autoreleasepool， 避免短时间内内存猛涨发生OOM 内存分配: malloc用的是 malloc_zone_malloc, calloc用的是malloc_zone_calloc 在处理图片缩放时，ImageIO占用内存会比直接处理图片缩放小 */</summary></entry><entry><title type="html">IM总结</title><link href="http://localhost:4000/IM%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="IM总结" /><published>2020-05-25T00:00:00+08:00</published><updated>2020-05-25T00:00:00+08:00</updated><id>http://localhost:4000/IM%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/IM%E6%80%BB%E7%BB%93/">&lt;h5 id=&quot;socket长连接的创建与维护&quot;&gt;Socket长连接的创建与维护&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;所有数据收发流程，均通过Socket长连接完成，如何维护一个稳定Socket通道，是IM系统是否稳定的重要一环&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-08346cb09a4d9c97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用连接请求接口，会开始连接的创建过程，创建成功后，会完成鉴权操作，当创建和鉴权都完成后，会开启消息收发线程，为了维持长连接，会有心跳机制，特别的，会开启一个心跳轮询线程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;心跳机制，是IM系统设计中的常见概念，简单的解释就是每隔若干时间发送一个固定信息给服务端，服务端收到后及时回复一个固定信息，如果服务端若干时间内没有收到客户端心跳信息则视客户端断开，同理如果客户端若干时间没有收到服务端心跳回值则视服务端断开&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-543f9422faad06d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当长连接创建成功后，会开启一个轮询线程，每隔一段时间发送心跳消息给服务器端，以维持长连接&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重连流程
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-21aa979e280bb85f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;聊天会话数据加载策略&quot;&gt;聊天会话数据加载策略&lt;/h4&gt;
&lt;p&gt;用户聊天时，需要将已经发送和接收到的聊天信息保存到本地。而不是每次都拉取历史数据。以达到节约流量和无网络状态下也查看数据的效果&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IM会话首次请求数据流程
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-521b1c2cae77ae39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IM下拉获取历史数据流程
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-a7e9213bba7026ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IM单条消息发送持久化方案
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-3aa4b8107e5ca390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IM单条数据重发流程
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-f8177e4089dc6d9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;消息回执&quot;&gt;消息回执&lt;/h5&gt;
&lt;p&gt;发送方增加已送到和未送达的状态，接收方收到消息后，给服务器返回已收到消息的通知，服务器再推送给发送方该状态，如果没有收到接收方回执，服务器可尝试重新推送。发送方接受到接收方的收到回执后，更新发送状态已发送，如果未收到，则显示未送达。为了防止接收方回执丢失，接收方接收消息时候，可维护本地去重队列&lt;/p&gt;

&lt;h4 id=&quot;im消息的逻辑流程&quot;&gt;IM消息的逻辑流程&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;消息接收：
网络模块通过跟IM服务端保持的长连接接收IM消息；&lt;/li&gt;
  &lt;li&gt;消息入库：
网络模块会将IM消息存入本地数据库，即信件投入了韩梅梅家的邮箱。网络模块就是邮递员，本地数据库就是韩梅梅家的邮箱；&lt;/li&gt;
  &lt;li&gt;消息展示：
界面模块获取发送人头像，和消息内容一起显示在聊天界面上。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;传输层协议-传输格式&quot;&gt;传输层协议 传输格式&lt;/h4&gt;

&lt;p&gt;数据协议存在文本协议和二进制协议两种类型&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文本协议直观、描述性强，容易理解、便与调试，并且协议修改方便，但是数据冗余较多，安全性稍差；&lt;/li&gt;
  &lt;li&gt;二进制协议格式精简、冗余数据少，窃听成本更高，但是数据不直观、调试略微复杂，使用、升级维护都需要约定好规则。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为优化App的网络请求速度和减小数据包大小，并配合接入层后台往C++框架改造，我们App的接入层网络数据传输协议切换成了二进制协议。协议数据包的定义统一采用协议头+业务包体(协议内容)的方式，协议头中用若干比特位定义协议版本号、数据包长度等信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-da1cba77e49d3863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;请求结构体&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4499332-7ce50dff6e3aa29d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;响应结构体&quot; /&gt;&lt;/p&gt;

&lt;p&gt;请求协议的协议头中包含业务标志、协议版本号和数据包长度，服务端只处理以业务标志开头的数据包：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;截取协议头后，用PkgReq结构体解析协议头中指定长度的数据包。&lt;/li&gt;
  &lt;li&gt;PkgReq包括明文的协议包头PkgReqHead和密文的二进制流。&lt;/li&gt;
  &lt;li&gt;PkgReqHead中会包括客户端生成的请求序列号，密文的加密方式、压缩方式等信息，用这些信息解开加密压缩过的PkgReqBody。&lt;/li&gt;
  &lt;li&gt;PkgReqBody包含通用请求数据ReqHead和业务请求数据ReqBody数组。&lt;/li&gt;
  &lt;li&gt;ReqHead中主要包括用户的设备信息、App版本信息、账号信息、网络环境等等基础信息，ReqBody则是具体请求命令字和业务请求结构体的封装。&lt;/li&gt;
  &lt;li&gt;若是多个命令字的合并请求则会有多个ReqBody，而ReqHead只需要有一份。&lt;/li&gt;
  &lt;li&gt;后台路由层根据ReqBody中的命令字cmdid将ReqBody中的businessReqBody字段转发到具体的后台服务进行处理。&lt;/li&gt;
  &lt;li&gt;并且ReqHead中设计了guid字段，后台会存储用户的设备信息并且给用户分配唯一的guid，客户端拿到guid之后，后续的请求就不需要上报不变的设备信息字段，只需要上传guid，后端可以根据guid按需获取用户设备信息，减小请求数据量。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;响应协议与请求协议的整体结构类似，由于响应需要返回错误码或返回码给客户端，并且存在合并请求，因此设计了两层返回码。在RspHead中有整体返回码iRet，作为路由层整体的处理结果；每个RspBody中还有ret，作为该命令字对应的后台服务的返回结果。每个RspBody中的businessRspBody在iRet和ret同时有效时才能用该命令字对应的响应结构体进行解包&lt;/p&gt;

&lt;h4 id=&quot;传输安全&quot;&gt;传输安全&lt;/h4&gt;

&lt;p&gt;二进制协议方案与文本协议方案类似，都需要考虑数据安全性的问题。二进制协议由于传输的数据包是二进制流，抓包并不能直接看到结构体，例如我们采用的jce协议，必须知道完整的数据格式才能解析出原始数据。在我们的方案中还采用了https、对协议中的内容数据PkgReqBody/PkgRspBody进行先压缩后加密等操作保证安全性&lt;/p&gt;

&lt;p&gt;二进制协议方案中，采用的AES加密，与文本协议不同的是采用AES的GCM模式。AES作为一种分组对称加密算法，需要对明文进行分组，分组长度可为128或256bits，有ECB，CBC，CTR等多种模式，这里不做具体介绍。GCM模式可以提供对消息的加密和完整性校验，具体原理这里不作详细介绍，可以参考文章《&lt;a href=&quot;https://blog.csdn.net/t0mato_/article/details/53160772&quot;&gt;什么是 AES-GCM加密算法&lt;/a&gt;》。AES-GCM加密也需要密钥key、初始向量iv，并且加密之后除了得到密文，还会得到消息校验码。在数据接收方可以通过这个校验码校验密文是否有篡改。在具体实现中，为增强安全性，iv由请求序列号和key按照一定规则动态生成，并将加密得到的校验码填写在协议包头PkgReqHead/PkgRspHead中，在解密时需要作为验证条件&lt;/p&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">Socket长连接的创建与维护 所有数据收发流程，均通过Socket长连接完成，如何维护一个稳定Socket通道，是IM系统是否稳定的重要一环 用连接请求接口，会开始连接的创建过程，创建成功后，会完成鉴权操作，当创建和鉴权都完成后，会开启消息收发线程，为了维持长连接，会有心跳机制，特别的，会开启一个心跳轮询线程。 心跳机制，是IM系统设计中的常见概念，简单的解释就是每隔若干时间发送一个固定信息给服务端，服务端收到后及时回复一个固定信息，如果服务端若干时间内没有收到客户端心跳信息则视客户端断开，同理如果客户端若干时间没有收到服务端心跳回值则视服务端断开 当长连接创建成功后，会开启一个轮询线程，每隔一段时间发送心跳消息给服务器端，以维持长连接 重连流程 聊天会话数据加载策略 用户聊天时，需要将已经发送和接收到的聊天信息保存到本地。而不是每次都拉取历史数据。以达到节约流量和无网络状态下也查看数据的效果 IM会话首次请求数据流程 IM下拉获取历史数据流程 IM单条消息发送持久化方案 IM单条数据重发流程 消息回执 发送方增加已送到和未送达的状态，接收方收到消息后，给服务器返回已收到消息的通知，服务器再推送给发送方该状态，如果没有收到接收方回执，服务器可尝试重新推送。发送方接受到接收方的收到回执后，更新发送状态已发送，如果未收到，则显示未送达。为了防止接收方回执丢失，接收方接收消息时候，可维护本地去重队列 IM消息的逻辑流程 消息接收： 网络模块通过跟IM服务端保持的长连接接收IM消息； 消息入库： 网络模块会将IM消息存入本地数据库，即信件投入了韩梅梅家的邮箱。网络模块就是邮递员，本地数据库就是韩梅梅家的邮箱； 消息展示： 界面模块获取发送人头像，和消息内容一起显示在聊天界面上。 传输层协议 传输格式 数据协议存在文本协议和二进制协议两种类型 文本协议直观、描述性强，容易理解、便与调试，并且协议修改方便，但是数据冗余较多，安全性稍差； 二进制协议格式精简、冗余数据少，窃听成本更高，但是数据不直观、调试略微复杂，使用、升级维护都需要约定好规则。 为优化App的网络请求速度和减小数据包大小，并配合接入层后台往C++框架改造，我们App的接入层网络数据传输协议切换成了二进制协议。协议数据包的定义统一采用协议头+业务包体(协议内容)的方式，协议头中用若干比特位定义协议版本号、数据包长度等信息 请求协议的协议头中包含业务标志、协议版本号和数据包长度，服务端只处理以业务标志开头的数据包： 截取协议头后，用PkgReq结构体解析协议头中指定长度的数据包。 PkgReq包括明文的协议包头PkgReqHead和密文的二进制流。 PkgReqHead中会包括客户端生成的请求序列号，密文的加密方式、压缩方式等信息，用这些信息解开加密压缩过的PkgReqBody。 PkgReqBody包含通用请求数据ReqHead和业务请求数据ReqBody数组。 ReqHead中主要包括用户的设备信息、App版本信息、账号信息、网络环境等等基础信息，ReqBody则是具体请求命令字和业务请求结构体的封装。 若是多个命令字的合并请求则会有多个ReqBody，而ReqHead只需要有一份。 后台路由层根据ReqBody中的命令字cmdid将ReqBody中的businessReqBody字段转发到具体的后台服务进行处理。 并且ReqHead中设计了guid字段，后台会存储用户的设备信息并且给用户分配唯一的guid，客户端拿到guid之后，后续的请求就不需要上报不变的设备信息字段，只需要上传guid，后端可以根据guid按需获取用户设备信息，减小请求数据量。 响应协议与请求协议的整体结构类似，由于响应需要返回错误码或返回码给客户端，并且存在合并请求，因此设计了两层返回码。在RspHead中有整体返回码iRet，作为路由层整体的处理结果；每个RspBody中还有ret，作为该命令字对应的后台服务的返回结果。每个RspBody中的businessRspBody在iRet和ret同时有效时才能用该命令字对应的响应结构体进行解包 传输安全 二进制协议方案与文本协议方案类似，都需要考虑数据安全性的问题。二进制协议由于传输的数据包是二进制流，抓包并不能直接看到结构体，例如我们采用的jce协议，必须知道完整的数据格式才能解析出原始数据。在我们的方案中还采用了https、对协议中的内容数据PkgReqBody/PkgRspBody进行先压缩后加密等操作保证安全性 二进制协议方案中，采用的AES加密，与文本协议不同的是采用AES的GCM模式。AES作为一种分组对称加密算法，需要对明文进行分组，分组长度可为128或256bits，有ECB，CBC，CTR等多种模式，这里不做具体介绍。GCM模式可以提供对消息的加密和完整性校验，具体原理这里不作详细介绍，可以参考文章《什么是 AES-GCM加密算法》。AES-GCM加密也需要密钥key、初始向量iv，并且加密之后除了得到密文，还会得到消息校验码。在数据接收方可以通过这个校验码校验密文是否有篡改。在具体实现中，为增强安全性，iv由请求序列号和key按照一定规则动态生成，并将加密得到的校验码填写在协议包头PkgReqHead/PkgRspHead中，在解密时需要作为验证条件</summary></entry><entry><title type="html">IAP记录</title><link href="http://localhost:4000/IAP%E5%86%85%E8%B4%AD/" rel="alternate" type="text/html" title="IAP记录" /><published>2020-04-25T00:00:00+08:00</published><updated>2020-04-25T00:00:00+08:00</updated><id>http://localhost:4000/IAP%E5%86%85%E8%B4%AD</id><content type="html" xml:base="http://localhost:4000/IAP%E5%86%85%E8%B4%AD/">&lt;h5 id=&quot;记录苹果iap内购的流程&quot;&gt;记录苹果IAP内购的流程&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;先在Apple Developer官网，签署相关的协议， 完善相应的信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在APP下添加内购项目， 选择内购产品的类型， 共四种类型，下面有总结&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输入商品相应的信息，产品id， 建议用bundleID加商品id, 组成的字符串，保证唯一性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择价格，上传审核图和审核信息， 保存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;商品显示可用后，即可开始Coding, coding完成后提交审核方可真实使用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;内购商品类型-解释&quot;&gt;内购商品类型 解释&lt;/h6&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.消耗型商品
顾名思义, 可以消耗使用的商品, 比如游戏中的金币, 钻石等, 可以用来购买应用内虚拟物品的货币。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.非消耗型商品
无法被消耗的商品，比如一些教育型APP中的课程, 再比如一些赛车游戏中的赛道, 这类商品需要在审核添加恢复购买按钮, 用于用户购买过后再误删除或其他原因卸载APP后的恢复流程, 否则提交审核会被拒绝。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3.非续期订阅
此类商品与消耗型商品类似, 比如一个月的会员, 一个季度的会员等,与消耗型商品的差异在于, 这类商品在验证凭证时需要传递共享秘钥&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4.自动续期订阅
这类商品和其他商品的流程也有些许不同, 应用比如视频APP中的连续包月会员, 此类商品到期会自动扣费, 服务器的验证逻辑也会有所不同,流程可以参考这篇文章&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;iap原理解释&quot;&gt;IAP原理解释&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;IAP的支付方式和微信，支付宝等的第三方支付的方式完全不同，下面分别记录下支付的区别，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;微信支付宝等第三方支付主要以Server驱动相应的业务，客户端流程大概如下 (用户选择商品 -&amp;gt; 服务端生成订单 -&amp;gt; 生成第三方需要的签名等相关信息给到客户端 -&amp;gt; 客户端调起第三方应用支付 -&amp;gt; 第三方回调客户端 -&amp;gt; 客户端向Server查询最终支付结果 -&amp;gt; 支付完成)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IAP的方式不同，IAP主要是以客户端驱动， Server仅仅用来校验Apple返回的支付凭证， Apple提供相应的代理方法， 告知客户端支付的进行状态， 因为客户端的情况复杂， 再加上IAP的国外服务器返回的问题，所以在IAP过程中，会出现很多奇怪的问题，下面开始逐步记录如何进行IAP&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;iap-coding&quot;&gt;IAP Coding&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;需要引入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import StoreKit&lt;/code&gt;， IAP所有的方法都在这个框架内部&lt;/li&gt;
  &lt;li&gt;根据产品的id查询IAP服务器上的相应的商品信息, 方法如下， 传入productIdentifiers
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let request = SKProductsRequest(productIdentifiers: productIdentifiers)
     request.delegate = self
     request.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;实现delegate方法，  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SKProductsRequestDelegate&lt;/code&gt;, 回调如下&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) {

   let products : [SKProduct] = response.products
   
   /// 可以从product中获取到如下信息
   DLog(&quot;product price: \(product.price)&quot;)
   DLog(&quot;product description: \(product.description)&quot;)
   DLog(&quot;product productIdentifier: \(product.productIdentifier)&quot;)
   DLog(&quot;product title: \(product.localizedTitle)&quot;)
   DLog(&quot;applicationUsername: \(IAPOrder.applicationUsername ?? &quot;&quot;)&quot;)
   
 /// 开始支付
 let payment = SKMutablePayment(product: product)
/// 发起支付时候指定用户的username, 在掉单时候验证防止切换账号导致充值错误
  payment.applicationUsername = IAPOrder.applicationUsername
SKPaymentQueue.default().add(payment)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;我们需要实现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SKProductsRequestDelegate&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在需要实现IAP的Class监听IAP的Observer， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SKPaymentTransactionObserver&lt;/code&gt;, 这个Observer主要负责监听IAP的各种状态&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">记录苹果IAP内购的流程 先在Apple Developer官网，签署相关的协议， 完善相应的信息 在APP下添加内购项目， 选择内购产品的类型， 共四种类型，下面有总结 输入商品相应的信息，产品id， 建议用bundleID加商品id, 组成的字符串，保证唯一性 选择价格，上传审核图和审核信息， 保存 商品显示可用后，即可开始Coding, coding完成后提交审核方可真实使用 内购商品类型 解释 1.消耗型商品 顾名思义, 可以消耗使用的商品, 比如游戏中的金币, 钻石等, 可以用来购买应用内虚拟物品的货币。 2.非消耗型商品 无法被消耗的商品，比如一些教育型APP中的课程, 再比如一些赛车游戏中的赛道, 这类商品需要在审核添加恢复购买按钮, 用于用户购买过后再误删除或其他原因卸载APP后的恢复流程, 否则提交审核会被拒绝。 3.非续期订阅 此类商品与消耗型商品类似, 比如一个月的会员, 一个季度的会员等,与消耗型商品的差异在于, 这类商品在验证凭证时需要传递共享秘钥 4.自动续期订阅 这类商品和其他商品的流程也有些许不同, 应用比如视频APP中的连续包月会员, 此类商品到期会自动扣费, 服务器的验证逻辑也会有所不同,流程可以参考这篇文章 IAP原理解释 IAP的支付方式和微信，支付宝等的第三方支付的方式完全不同，下面分别记录下支付的区别， 微信支付宝等第三方支付主要以Server驱动相应的业务，客户端流程大概如下 (用户选择商品 -&amp;gt; 服务端生成订单 -&amp;gt; 生成第三方需要的签名等相关信息给到客户端 -&amp;gt; 客户端调起第三方应用支付 -&amp;gt; 第三方回调客户端 -&amp;gt; 客户端向Server查询最终支付结果 -&amp;gt; 支付完成) IAP的方式不同，IAP主要是以客户端驱动， Server仅仅用来校验Apple返回的支付凭证， Apple提供相应的代理方法， 告知客户端支付的进行状态， 因为客户端的情况复杂， 再加上IAP的国外服务器返回的问题，所以在IAP过程中，会出现很多奇怪的问题，下面开始逐步记录如何进行IAP IAP Coding 需要引入 import StoreKit， IAP所有的方法都在这个框架内部 根据产品的id查询IAP服务器上的相应的商品信息, 方法如下， 传入productIdentifiers let request = SKProductsRequest(productIdentifiers: productIdentifiers) request.delegate = self request.start() 实现delegate方法， SKProductsRequestDelegate, 回调如下 func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { let products : [SKProduct] = response.products /// 可以从product中获取到如下信息 DLog(&quot;product price: \(product.price)&quot;) DLog(&quot;product description: \(product.description)&quot;) DLog(&quot;product productIdentifier: \(product.productIdentifier)&quot;) DLog(&quot;product title: \(product.localizedTitle)&quot;) DLog(&quot;applicationUsername: \(IAPOrder.applicationUsername ?? &quot;&quot;)&quot;) /// 开始支付 let payment = SKMutablePayment(product: product) /// 发起支付时候指定用户的username, 在掉单时候验证防止切换账号导致充值错误 payment.applicationUsername = IAPOrder.applicationUsername SKPaymentQueue.default().add(payment) } 我们需要实现 SKProductsRequestDelegate 在需要实现IAP的Class监听IAP的Observer， SKPaymentTransactionObserver, 这个Observer主要负责监听IAP的各种状态</summary></entry><entry><title type="html">centOS 常规操作</title><link href="http://localhost:4000/CentOs%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C/" rel="alternate" type="text/html" title="centOS 常规操作" /><published>2020-04-20T00:00:00+08:00</published><updated>2020-04-20T00:00:00+08:00</updated><id>http://localhost:4000/CentOs%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C</id><content type="html" xml:base="http://localhost:4000/CentOs%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C/">&lt;h4 id=&quot;安装jdk&quot;&gt;安装JDK&lt;/h4&gt;
&lt;p&gt;手动安装方式&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir /usr/java
tar -xzvf jdk-8u45-linux-x64.tar.gz -C /usr/java/
#切记必须修正所属⽤户及⽤户组
chown -R root:root /usr/java/jdk1.8.0_45
echo &quot;export JAVA_HOME=/usr/java/jdk1.8.0_45&quot; &amp;gt;&amp;gt; /etc/profile
echo &quot;export PATH=${JAVA_HOME}/bin:${PATH}&quot; &amp;gt;&amp;gt; /etc/profile
source /etc/profile
which java
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;安装mysql&quot;&gt;安装MySql&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tar -zxvf mysql-5.7.11-linux-glibc2.5-x86_64.tar.gz
mv mysql-5.7.11-linux-glibc2.5-x86_64 mysql
mv mysql /usr/local
chown -R root:root mysql
# 在local目录下
mkdir mysql/arch mysql/data mysql/tmp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;创建用户组及用户&quot;&gt;创建用户组及用户&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;groupadd -g 101 dba
useradd -u 514 -g dba -G root -d /usr/local/mysql mysqladmin
id mysqladmin
# 一般不需要设置mysqladmin的密码，直接从root或者LDAP用户sudo切换
passwd mysqladmin
# 输入两次密码
usermod -u 514 -g dba -G root -d /usr/local/mysql mysqladmin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;copy-环境变量配置文件至mysqladmin用户的home目录中为了以下步骤配置个人环境变量&quot;&gt;copy 环境变量配置文件至mysqladmin用户的home目录中,为了以下步骤配置个人环境变量&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp /etc/skel/.* /usr/local/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;配置环境变量&quot;&gt;配置环境变量&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;vi mysql/.bash_profile&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# .bash_profile
# Get the aliases and functions

if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs
export MYSQL_BASE=/usr/local/mysql
export PATH=${MYSQL_BASE}/bin:$PATH


unset USERNAME

#stty erase ^H
set umask to 022
umask 022
PS1=`uname -n`&quot;:&quot;'$USER'&quot;:&quot;'$PWD'&quot;:&amp;gt;&quot;; export PS1

## end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;赋权限和用户组切换用户mysqladmin安装&quot;&gt;赋权限和用户组，切换用户mysqladmin，安装&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chown  mysqladmin:dba /etc/my.cnf
chmod  640 /etc/my.cnf
chown -R mysqladmin:dba /usr/local/mysql
chmod -R 755 /usr/local/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;配置服务及开机自启动&quot;&gt;配置服务及开机自启动&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/local/mysql
# 将服务文件拷贝到init.d下，并重命名为mysql
cp support-files/mysql.server /etc/rc.d/init.d/mysql
# 赋予可执行权限
chmod +x /etc/rc.d/init.d/mysql
# 删除服务
chkconfig --del mysql
# 添加服务
chkconfig --add mysql
chkconfig --level 345 mysql on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;安装libaio及安装mysql的初始db&quot;&gt;安装libaio及安装mysql的初始db&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum -y install libaio
sudo su - mysqladmin
bin/mysqld \
--defaults-file=/etc/my.cnf \
--user=mysqladmin \
--basedir=/usr/local/mysql/ \
--datadir=/usr/local/mysql/data/ \
--initialize
#　在初始化时如果加上 –initial-insecure，则会创建空密码的 root@localhost 账号，否则会创建带密码的 root@localhost 账号，密码直接写在 log-error 日志文件中
#  （在5.6版本中是放在 ~/.mysql_secret 文件里，更加隐蔽，不熟悉的话可能会无所适从）
cd data
cat hostname.err |grep password # 查看临时密码，复制保存
cd ..
# 启动mysql，2次回车
/usr/local/mysql/bin/mysqld_safe --defaults-file=/etc/my.cnf &amp;amp;
# 查看状态
service mysql status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;查看mysql是否成功启动&quot;&gt;查看mysql是否成功启动&lt;/h5&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exit; # 退出
ps -ef | grep mysql  # 查看mysql端口
netstat -nlp | grep 12022 # 查看端口对应的服务，能看到3306端口
su - mysqladmin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;登录及修改用户密码-重启&quot;&gt;登录及修改用户密码, 重启&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -u root -p '*****' # *****是复制的临时密码
alter user root@localhost identified by '123456';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' ;
flush privileges;
exit;
service mysql restart
mysql -u root -123456
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">安装JDK 手动安装方式 mkdir /usr/java tar -xzvf jdk-8u45-linux-x64.tar.gz -C /usr/java/ #切记必须修正所属⽤户及⽤户组 chown -R root:root /usr/java/jdk1.8.0_45 echo &quot;export JAVA_HOME=/usr/java/jdk1.8.0_45&quot; &amp;gt;&amp;gt; /etc/profile echo &quot;export PATH=${JAVA_HOME}/bin:${PATH}&quot; &amp;gt;&amp;gt; /etc/profile source /etc/profile which java 安装MySql tar -zxvf mysql-5.7.11-linux-glibc2.5-x86_64.tar.gz mv mysql-5.7.11-linux-glibc2.5-x86_64 mysql mv mysql /usr/local chown -R root:root mysql # 在local目录下 mkdir mysql/arch mysql/data mysql/tmp 创建用户组及用户 groupadd -g 101 dba useradd -u 514 -g dba -G root -d /usr/local/mysql mysqladmin id mysqladmin # 一般不需要设置mysqladmin的密码，直接从root或者LDAP用户sudo切换 passwd mysqladmin # 输入两次密码 usermod -u 514 -g dba -G root -d /usr/local/mysql mysqladmin copy 环境变量配置文件至mysqladmin用户的home目录中,为了以下步骤配置个人环境变量 cp /etc/skel/.* /usr/local/mysql 配置环境变量 vi mysql/.bash_profile # .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs export MYSQL_BASE=/usr/local/mysql export PATH=${MYSQL_BASE}/bin:$PATH unset USERNAME #stty erase ^H set umask to 022 umask 022 PS1=`uname -n`&quot;:&quot;'$USER'&quot;:&quot;'$PWD'&quot;:&amp;gt;&quot;; export PS1 ## end 赋权限和用户组，切换用户mysqladmin，安装 chown mysqladmin:dba /etc/my.cnf chmod 640 /etc/my.cnf chown -R mysqladmin:dba /usr/local/mysql chmod -R 755 /usr/local/mysql 配置服务及开机自启动 cd /usr/local/mysql # 将服务文件拷贝到init.d下，并重命名为mysql cp support-files/mysql.server /etc/rc.d/init.d/mysql # 赋予可执行权限 chmod +x /etc/rc.d/init.d/mysql # 删除服务 chkconfig --del mysql # 添加服务 chkconfig --add mysql chkconfig --level 345 mysql on 安装libaio及安装mysql的初始db yum -y install libaio sudo su - mysqladmin bin/mysqld \ --defaults-file=/etc/my.cnf \ --user=mysqladmin \ --basedir=/usr/local/mysql/ \ --datadir=/usr/local/mysql/data/ \ --initialize #　在初始化时如果加上 –initial-insecure，则会创建空密码的 root@localhost 账号，否则会创建带密码的 root@localhost 账号，密码直接写在 log-error 日志文件中 # （在5.6版本中是放在 ~/.mysql_secret 文件里，更加隐蔽，不熟悉的话可能会无所适从） cd data cat hostname.err |grep password # 查看临时密码，复制保存 cd .. # 启动mysql，2次回车 /usr/local/mysql/bin/mysqld_safe --defaults-file=/etc/my.cnf &amp;amp; # 查看状态 service mysql status 查看mysql是否成功启动 exit; # 退出 ps -ef | grep mysql # 查看mysql端口 netstat -nlp | grep 12022 # 查看端口对应的服务，能看到3306端口 su - mysqladmin 登录及修改用户密码, 重启 mysql -u root -p '*****' # *****是复制的临时密码 alter user root@localhost identified by '123456'; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' ; flush privileges; exit; service mysql restart mysql -u root -123456</summary></entry><entry><title type="html">日记</title><link href="http://localhost:4000/%E6%96%B0%E5%86%A0%E6%9C%9F%E9%97%B4%E7%9A%84%E6%97%A5%E8%AE%B0/" rel="alternate" type="text/html" title="日记" /><published>2020-02-15T00:00:00+08:00</published><updated>2020-02-15T00:00:00+08:00</updated><id>http://localhost:4000/%E6%96%B0%E5%86%A0%E6%9C%9F%E9%97%B4%E7%9A%84%E6%97%A5%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/%E6%96%B0%E5%86%A0%E6%9C%9F%E9%97%B4%E7%9A%84%E6%97%A5%E8%AE%B0/">&lt;h5 id=&quot;好久没更新个人博客网站了今天来写篇日记&quot;&gt;好久没更新个人博客网站了，今天来写篇日记&lt;/h5&gt;

&lt;h6 id=&quot;2020年2月15日-小雪转晴&quot;&gt;2020年2月15日 小雪转晴&lt;/h6&gt;

&lt;p&gt;作为一个离重灾区武汉只有四百公里的次重灾区的同学，今天是被在家隔离的第23天，此时的我百感交集，五味杂陈，多种滋味，带着这样的一种心情，记录此篇博客(不对，是日记)&lt;/p&gt;

&lt;h6 id=&quot;不平凡的2020&quot;&gt;不平凡的2020&lt;/h6&gt;

&lt;p&gt;2020年注定是不平凡的一年，19年12月底开始武汉发生了新冠肺炎，大武汉，我们的省会城市，也是除了家乡和上海外最最熟悉的一座城市(比起北 广，深，虽然也去过多次)，对于武汉，并没有因为一场病毒，而对一座城市产生不好的看法(当然会对城市管理者有一定的看法)，在武汉封城的前一天经过了武汉，还和武汉的朋友见了个面&lt;/p&gt;

&lt;h6 id=&quot;1月中新冠早期&quot;&gt;1月中(新冠早期)&lt;/h6&gt;

&lt;p&gt;1月中旬，当时在外网看到一些新闻(要翻墙哦)，说武汉华南海鲜城出现了一种很奇怪的病毒，存在人传人，当时香港的一个医生去武汉后很害怕(毕竟香港是当年SARS的主要发生地)，那时国内的新闻报道这个的还不多。 本着历来外媒的可信度，当时还和一些朋友说了武汉肺炎这个事情有点像SARS归来(由于年龄关系，对SARS没什么影响，只能通过资料去看)，朋友说不要信。&lt;/p&gt;

&lt;h6 id=&quot;继续1月中&quot;&gt;继续1月中&lt;/h6&gt;

&lt;p&gt;和室友(医药行业的质量管理)闲聊，可能是行业原因(毕竟知名药企工作多年), 对其非常警惕，然后又给我科普了下当年SARS，我也就开始警惕起来&lt;/p&gt;

&lt;h6 id=&quot;几天后&quot;&gt;几天后&lt;/h6&gt;

&lt;p&gt;国内的媒体开始报道这个事件，也看到一些小道消息(可能是谣言，也可能是事实，无法验证)报道很严重，这时有部分人先知先觉开始关注，开始买口罩，这时听武汉的朋友说口罩已经不那么好买到了，本着安全的考虑，在上海也开始买起了口罩，并给家里人交代也要买(尽管很难说服)&lt;/p&gt;

&lt;h6 id=&quot;过年前几天&quot;&gt;过年前几天&lt;/h6&gt;

&lt;p&gt;从上海回老家，中途在武汉换乘，一个月前和武汉的几位朋友相约在武汉相聚，朋友们特地在武汉等我，我们特地去了人非常少的且离所谓的事发地很远的地方，大家都做了防护，中午一起吃了个饭，聊了会人生(哈哈哈，闲聊而已), 下午我们便各回各家了。 第二天一大早，得知武汉全城封锁，后来朋友们还在说幸好他们回去的早，不然回不去了，我们还在在暗自庆幸&lt;/p&gt;

&lt;h6 id=&quot;武汉封城&quot;&gt;武汉封城&lt;/h6&gt;

&lt;p&gt;突然得知武汉封城(尽管几天前曾听说过封城的小道消息), 这个时候大家就意识到事情已经非常严重了，能让整个城市封锁(好像翻遍历史也没几次吧)，社会开始恐慌，好像各地都在疯狂买口罩(装备已经提前备好了), 事件进一步升级&lt;/p&gt;

&lt;h6 id=&quot;封城第二天除夕&quot;&gt;封城第二天(除夕)&lt;/h6&gt;

&lt;p&gt;武汉周边的城市也开始封城，气氛越来越紧张，早上起来后，就给武汉的亲戚们挨个打了个电话，一是问他们在武汉的情况(并叮嘱他们)，二是过年了，向他们问个好。一圈问下来，发现都还好，这是心中的石头放下了，说明他们是安全的，心中一直期望着一切都好。 这年除夕，很安静，只有我们自己一家人过年，聊天，看春晚，打牌&lt;/p&gt;

&lt;h6 id=&quot;大年初一&quot;&gt;大年初一&lt;/h6&gt;

&lt;p&gt;凌晨，所在的城市发布了封城通告，也意味着全省封锁了，我们是最后一个封城的。 按照正常情况，大年初一要开始拜年了，而今年不一样，因为新冠，我们决定不出门了，开始电话和微信拜年，并和亲戚们解释，一说大家都通了，也就都不串门，开始了特别的线上的拜年方式，2020注定不一样。 有些朋友看到所在的城市封城了，也发来了慰问，我向他们道了好，也让他们安心。&lt;/p&gt;

&lt;h6 id=&quot;初二到初十&quot;&gt;初二到初十&lt;/h6&gt;

&lt;p&gt;每天早上醒来第一件事就是打开头条，看看新冠的新闻和数据，期待着数据出现拐点。 每天都在关注钟南山，CCTV新闻频道，新冠，已经变成了生活日常。国家也开始出台了很多政策，比如春节延期，放缓企业复工，各地都在拼尽全力抵抗新冠，我也尽了我我的绵薄之力，为大武汉捐了一点点钱&lt;/p&gt;

&lt;h6 id=&quot;初十以后&quot;&gt;初十以后&lt;/h6&gt;

&lt;p&gt;新闻还是很多，数据还是指数级增长，不容乐观。逐渐开始在家办公，因为这次事件，其实对全社会的损失是都是相当大的。 所以我们开始了在家远程办公，逐步开始工作，工作的事情略(不记录了)&lt;/p&gt;

&lt;h6 id=&quot;至今&quot;&gt;至今&lt;/h6&gt;

&lt;p&gt;每天都在期待数据的拐点，期望早日结束，早日还人们健康和自由。自觉在家隔离，为国家做贡献，为患者祈福。挺国家的话&lt;/p&gt;

&lt;h6 id=&quot;总结一下吧&quot;&gt;总结一下吧&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;写完之后发现其实记录的都是流水账(这可能就是日记吧，手动笑脸，哈哈)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这次期间，也想了很多。对人的一生可能有有了一些新的想法，也摈弃了以前的一些想法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;好好珍惜生命，健康和安全第一，因为你不知道生命何时会结束，毕竟那么脆弱&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;好好孝顺父母，好好珍惜对待那些对你好的人，做到问心无愧，因为你不知道生命何时会结束。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多做一些有意义的事情，放弃那些无意义的，及时行乐，也别太委屈了自己。还是那句你真的不知道生命何时会结束。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于一些事，一些人，问心无愧就好，有些事情你真的改变不了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;还有就是要多存钱，肯定用得上(前提是安全第一，哈哈哈)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;写在最后&quot;&gt;写在最后&lt;/h6&gt;

&lt;p&gt;祝愿新冠早日被打败，朋友们一切安好，社会一片安详，武汉加油，中国加油&lt;/p&gt;

&lt;p&gt;最后引用诗人雪莱的一句话 “冬天到了，春天还会远吗？”&lt;/p&gt;

&lt;p&gt;2020年2月15日&lt;/p&gt;</content><author><name></name></author><category term="日记" /><summary type="html">好久没更新个人博客网站了，今天来写篇日记 2020年2月15日 小雪转晴 作为一个离重灾区武汉只有四百公里的次重灾区的同学，今天是被在家隔离的第23天，此时的我百感交集，五味杂陈，多种滋味，带着这样的一种心情，记录此篇博客(不对，是日记) 不平凡的2020 2020年注定是不平凡的一年，19年12月底开始武汉发生了新冠肺炎，大武汉，我们的省会城市，也是除了家乡和上海外最最熟悉的一座城市(比起北 广，深，虽然也去过多次)，对于武汉，并没有因为一场病毒，而对一座城市产生不好的看法(当然会对城市管理者有一定的看法)，在武汉封城的前一天经过了武汉，还和武汉的朋友见了个面 1月中(新冠早期) 1月中旬，当时在外网看到一些新闻(要翻墙哦)，说武汉华南海鲜城出现了一种很奇怪的病毒，存在人传人，当时香港的一个医生去武汉后很害怕(毕竟香港是当年SARS的主要发生地)，那时国内的新闻报道这个的还不多。 本着历来外媒的可信度，当时还和一些朋友说了武汉肺炎这个事情有点像SARS归来(由于年龄关系，对SARS没什么影响，只能通过资料去看)，朋友说不要信。 继续1月中 和室友(医药行业的质量管理)闲聊，可能是行业原因(毕竟知名药企工作多年), 对其非常警惕，然后又给我科普了下当年SARS，我也就开始警惕起来 几天后 国内的媒体开始报道这个事件，也看到一些小道消息(可能是谣言，也可能是事实，无法验证)报道很严重，这时有部分人先知先觉开始关注，开始买口罩，这时听武汉的朋友说口罩已经不那么好买到了，本着安全的考虑，在上海也开始买起了口罩，并给家里人交代也要买(尽管很难说服) 过年前几天 从上海回老家，中途在武汉换乘，一个月前和武汉的几位朋友相约在武汉相聚，朋友们特地在武汉等我，我们特地去了人非常少的且离所谓的事发地很远的地方，大家都做了防护，中午一起吃了个饭，聊了会人生(哈哈哈，闲聊而已), 下午我们便各回各家了。 第二天一大早，得知武汉全城封锁，后来朋友们还在说幸好他们回去的早，不然回不去了，我们还在在暗自庆幸 武汉封城 突然得知武汉封城(尽管几天前曾听说过封城的小道消息), 这个时候大家就意识到事情已经非常严重了，能让整个城市封锁(好像翻遍历史也没几次吧)，社会开始恐慌，好像各地都在疯狂买口罩(装备已经提前备好了), 事件进一步升级 封城第二天(除夕) 武汉周边的城市也开始封城，气氛越来越紧张，早上起来后，就给武汉的亲戚们挨个打了个电话，一是问他们在武汉的情况(并叮嘱他们)，二是过年了，向他们问个好。一圈问下来，发现都还好，这是心中的石头放下了，说明他们是安全的，心中一直期望着一切都好。 这年除夕，很安静，只有我们自己一家人过年，聊天，看春晚，打牌 大年初一 凌晨，所在的城市发布了封城通告，也意味着全省封锁了，我们是最后一个封城的。 按照正常情况，大年初一要开始拜年了，而今年不一样，因为新冠，我们决定不出门了，开始电话和微信拜年，并和亲戚们解释，一说大家都通了，也就都不串门，开始了特别的线上的拜年方式，2020注定不一样。 有些朋友看到所在的城市封城了，也发来了慰问，我向他们道了好，也让他们安心。 初二到初十 每天早上醒来第一件事就是打开头条，看看新冠的新闻和数据，期待着数据出现拐点。 每天都在关注钟南山，CCTV新闻频道，新冠，已经变成了生活日常。国家也开始出台了很多政策，比如春节延期，放缓企业复工，各地都在拼尽全力抵抗新冠，我也尽了我我的绵薄之力，为大武汉捐了一点点钱 初十以后 新闻还是很多，数据还是指数级增长，不容乐观。逐渐开始在家办公，因为这次事件，其实对全社会的损失是都是相当大的。 所以我们开始了在家远程办公，逐步开始工作，工作的事情略(不记录了) 至今 每天都在期待数据的拐点，期望早日结束，早日还人们健康和自由。自觉在家隔离，为国家做贡献，为患者祈福。挺国家的话 总结一下吧 写完之后发现其实记录的都是流水账(这可能就是日记吧，手动笑脸，哈哈) 在这次期间，也想了很多。对人的一生可能有有了一些新的想法，也摈弃了以前的一些想法 好好珍惜生命，健康和安全第一，因为你不知道生命何时会结束，毕竟那么脆弱 好好孝顺父母，好好珍惜对待那些对你好的人，做到问心无愧，因为你不知道生命何时会结束。 多做一些有意义的事情，放弃那些无意义的，及时行乐，也别太委屈了自己。还是那句你真的不知道生命何时会结束。 对于一些事，一些人，问心无愧就好，有些事情你真的改变不了 还有就是要多存钱，肯定用得上(前提是安全第一，哈哈哈) 写在最后 祝愿新冠早日被打败，朋友们一切安好，社会一片安详，武汉加油，中国加油 最后引用诗人雪莱的一句话 “冬天到了，春天还会远吗？” 2020年2月15日</summary></entry><entry><title type="html">iOS 启动优化总结</title><link href="http://localhost:4000/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="iOS 启动优化总结" /><published>2019-09-21T00:00:00+08:00</published><updated>2019-09-21T00:00:00+08:00</updated><id>http://localhost:4000/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/">&lt;h4 id=&quot;启动过程&quot;&gt;启动过程&lt;/h4&gt;

&lt;p&gt;注： 本Blog的总结来自阅读美团iOS Team的学习，部分图片来自美团 Team(侵权删)
&lt;img src=&quot;https://p0.meituan.net/travelcube/52635c087684765c9ee5b134c50226da136906.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;加载过程--从exec到main&quot;&gt;加载过程  从Exec()到Main()&lt;/h5&gt;

&lt;p&gt;真正的加载过程从exec()函数开始，exec()是一个系统调用。操作系统首先为进程分配一段内存空间，然后执行如下操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;把App对应的可执行文件加载到内存。&lt;/li&gt;
  &lt;li&gt;把Dyld加载到内存。&lt;/li&gt;
  &lt;li&gt;Dyld进行动态链接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/travelcube/db061a267f6dc2b14ff7f9120020a5c261253.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Dyld在各阶段处理的任务&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;加载动态库&lt;/li&gt;
  &lt;li&gt;Rebase和Bind&lt;/li&gt;
  &lt;li&gt;Objc setup&lt;/li&gt;
  &lt;li&gt;Initializers&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;加载动态库&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;从Header中获取所需要加载的动态的所依赖动态库列表，递归依赖集合&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Rebase Bind&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Rebase在Image内部调整指针的指向 Bind是指向Image外部的内容，指向外部的指针被Symbol绑定，Dyld要去符号表中查找对于的实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Objc setup&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;注册Class 插入Category的方法列表   保证每个Selector唯一&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Initializers&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Objc的Load方法  C++的构造函数属性函数  非基本类型的C++静态全局变量的创建(通常是类或结构体)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最后Dyld会调用main()函数，main()函数调用UIApplication()&lt;br /&gt;
可能影响main()函数启动过程的一些因素&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;动态库越多，加载越慢&lt;/li&gt;
  &lt;li&gt;Objc类方法越多，加载越慢&lt;/li&gt;
  &lt;li&gt;Objc load方法越多，加载越慢&lt;/li&gt;
  &lt;li&gt;C++静态对象越多，加载越慢&lt;/li&gt;
  &lt;li&gt;C的Constructor方法越多，加载越慢&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">启动过程 注： 本Blog的总结来自阅读美团iOS Team的学习，部分图片来自美团 Team(侵权删) 加载过程 从Exec()到Main() 真正的加载过程从exec()函数开始，exec()是一个系统调用。操作系统首先为进程分配一段内存空间，然后执行如下操作： 把App对应的可执行文件加载到内存。 把Dyld加载到内存。 Dyld进行动态链接。 Dyld在各阶段处理的任务 加载动态库 Rebase和Bind Objc setup Initializers 加载动态库 从Header中获取所需要加载的动态的所依赖动态库列表，递归依赖集合 Rebase Bind Rebase在Image内部调整指针的指向 Bind是指向Image外部的内容，指向外部的指针被Symbol绑定，Dyld要去符号表中查找对于的实现 Objc setup 注册Class 插入Category的方法列表 保证每个Selector唯一 Initializers Objc的Load方法 C++的构造函数属性函数 非基本类型的C++静态全局变量的创建(通常是类或结构体) 最后Dyld会调用main()函数，main()函数调用UIApplication() 可能影响main()函数启动过程的一些因素 动态库越多，加载越慢 Objc类方法越多，加载越慢 Objc load方法越多，加载越慢 C++静态对象越多，加载越慢 C的Constructor方法越多，加载越慢</summary></entry><entry><title type="html">曾国藩传读书笔记</title><link href="http://localhost:4000/%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="曾国藩传读书笔记" /><published>2019-08-24T00:00:00+08:00</published><updated>2019-08-24T00:00:00+08:00</updated><id>http://localhost:4000/%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">&lt;h3 id=&quot;最近在看曾国藩深有感触记录下读书笔记&quot;&gt;最近在看《曾国藩》深有感触，记录下读书笔记&lt;/h3&gt;

&lt;p&gt;曾国藩， 从湖南湘乡荷叶塘的一个农家子弟完全靠自己的能力与见识拜相封侯，晚晴第一重臣。学习曾国藩的为人处世的方式将使我一生受益无穷&lt;/p&gt;

&lt;h5 id=&quot;1-肯下苦工&quot;&gt;1. 肯下苦工&lt;/h5&gt;

&lt;p&gt;屋内背书5遍依然不会，而梁上君子已经可以背诵,年少的曾国藩并不太出众，但愿意下苦工来学习，正是这样的好习惯使得曾国藩一生受益，影响其做人，做官，带兵&lt;/p&gt;

&lt;h5 id=&quot;2曾国藩心细的表现&quot;&gt;2.曾国藩心细的表现&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;曾国藩来到养性殿。养性殿是皇宫收藏前代名人字画的宫殿，皇帝接见臣下，一般不在这里。守殿的大太监名叫过业大，人称大公公。国藩与大公公打声招呼后，便端坐在养性殿候驾。一坐整整两个时辰，时至正午，尚不见召，国藩心中犯疑，请大公公打听。一会儿，大公公告诉他：皇上今天不来了，明天在养心殿召见。 曾国藩是个心细的人，他回到家里，越想此事越蹊跷。在翰林院当差七年了，受皇上召见也有好几次，从来没有遇过这样的情况，也没有听说过有这样的事。他赶紧套上马车，去见恩师穆彰阿，请教此中原委。穆彰阿也觉得奇怪，详细询问事情的前前后后，和阗玉球在手中滚过百把圈后，他明白了。穆彰阿立即叫仆人带上三百两银子去找大公公，要大公公将养性殿内的陈设，尤其是四壁悬挂的字画，一幅不漏、一字不漏地抄出。夜间，大公公送来抄单。穆彰阿要曾国藩读熟记住&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;3郭嵩焘对曾传授为人做官的方法&quot;&gt;3.郭嵩焘对曾传授为人做官的方法&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;“你若像我这样，不在地方办事，又不带勇剿贼则罢，倘若指望办成大事，剿灭逆贼，你有些做法要改。” “旁观者清。我哪些地方做得不对，你就直言不讳吧！”曾国藩已感受到郭嵩焘的一片真心。 “第一，要联络好地方文武，不要总是站在与他们为敌的地位，当妥协处则妥协。常言说得好，强龙不压地头蛇。第二，越俎代庖之事不能再做，费力不讨好，反招怨敌。第三，要利用绿营的力量，不要再单枪匹马地干。若做到这三点，许多事情会办得好些。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;4兵败后被高人指点-从以前的柔刚-开始-柔&quot;&gt;4.兵败后被高人指点, 从以前的“柔刚“ 开始 ”柔“&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;曾国藩想起在长沙与绿营的龃龉斗法，与湖南官场的凿枘不合，想起在南昌与陈启迈、恽光宸的争强斗胜，这一切都是采取儒家直接、法家强权的方式。结果呢？表面上胜利了，实则埋下了更大的隐患。又如参清德、参陈启迈，越俎代庖、包揽干预种种情事，办理之时，固然痛快干脆，却没有想到锋芒毕露、刚烈太甚，伤害了清德、陈启迈的上上下下、左左右右，无形中给自己设置了许多障碍。这些隐患与障碍，如果不是自己亲身体验过，在书斋里、在六部签押房里是无论如何也设想不到的，它们对事业的损害，大大地超过了一时的风光和快意！既然直接的、以强对强的手法有时不能行得通，而迂回的、间接的、柔弱的方式也可以达到目的、战胜强者，且不至于留下隐患，为什么不采用呢？少年时代记住的诸如“大方无隅”“大音希声”“大象无形”“大巧若拙”的话，过去一直似懂非懂，现在一下子豁然开朗了。这些年来与官场内部以及与绿营的争斗，其实都是一种有隅之方，有声之音，有形之象，似巧实拙，真正的大方、大象、大巧不是这样的，它要做到全无形迹之嫌，全无斧凿之工。 “人之生也柔弱，其死也坚强，草木之生也柔脆，其死也枯槁。”柔弱、柔弱，天下万事万物，归根结底，莫不是以至柔克至刚。能克刚之柔，难道不是更刚吗？祖父“男儿以懦弱无刚为耻”的家训，自己竟片面理解了。曾国藩想到这里，兴奋地在《道德经》扉页上写下八个字：“大柔非柔，至刚无刚。”他觉得胸中的郁结解开了许多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;5老友胡林翼更好的体现了柔弱胜刚强&quot;&gt;5.老友胡林翼更好的体现了”柔弱胜刚强“&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;第二天一早，一顶花呢大轿将六姨太抬进巡抚衙门，胡太夫人、静娟夫人设盛宴款待，陪着玩牌听曲，扯家常。六姨太自幼丧母，见胡太夫人这样喜欢她，便认胡太夫人为母。胡太夫人高高兴兴地收下这个义女，又叫她拜见了兄长胡林翼。胡太夫人送给六姨太一副金镯金耳环金戒指，算是给义女的见面礼。六姨太回府后，在枕边对着官文说起胡家母子的千好万好。并说，从今以后两家认了亲，就是一家了，就不要再为难胡林翼了。官文对这个娇媚聪敏的六姨太向来百依百顺，果然从此再不给胡林翼找岔子了。军事民事，全付与胡林翼一手办理，他只在上面画诺而已；而胡林翼也表面上对他恭敬顺从。武昌城里督抚关系之亲密，为全国之首。 先前，曾国藩听到官胡这段故事后置之一笑。他笑胡林翼太软弱了，竟然用讨好一个姨太太的手腕来换取官文的合作，岂不太失堂堂大丈夫的气节！现在，他明白了，这正是胡林翼的高明之处，也是胡林翼胜过他的地方。“柔弱胜刚强”，胡林翼早已深懂此中之味，并运用得相当熟练了。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="读书笔记" /><summary type="html">最近在看《曾国藩》深有感触，记录下读书笔记 曾国藩， 从湖南湘乡荷叶塘的一个农家子弟完全靠自己的能力与见识拜相封侯，晚晴第一重臣。学习曾国藩的为人处世的方式将使我一生受益无穷 1. 肯下苦工 屋内背书5遍依然不会，而梁上君子已经可以背诵,年少的曾国藩并不太出众，但愿意下苦工来学习，正是这样的好习惯使得曾国藩一生受益，影响其做人，做官，带兵 2.曾国藩心细的表现 曾国藩来到养性殿。养性殿是皇宫收藏前代名人字画的宫殿，皇帝接见臣下，一般不在这里。守殿的大太监名叫过业大，人称大公公。国藩与大公公打声招呼后，便端坐在养性殿候驾。一坐整整两个时辰，时至正午，尚不见召，国藩心中犯疑，请大公公打听。一会儿，大公公告诉他：皇上今天不来了，明天在养心殿召见。 曾国藩是个心细的人，他回到家里，越想此事越蹊跷。在翰林院当差七年了，受皇上召见也有好几次，从来没有遇过这样的情况，也没有听说过有这样的事。他赶紧套上马车，去见恩师穆彰阿，请教此中原委。穆彰阿也觉得奇怪，详细询问事情的前前后后，和阗玉球在手中滚过百把圈后，他明白了。穆彰阿立即叫仆人带上三百两银子去找大公公，要大公公将养性殿内的陈设，尤其是四壁悬挂的字画，一幅不漏、一字不漏地抄出。夜间，大公公送来抄单。穆彰阿要曾国藩读熟记住 3.郭嵩焘对曾传授为人做官的方法 “你若像我这样，不在地方办事，又不带勇剿贼则罢，倘若指望办成大事，剿灭逆贼，你有些做法要改。” “旁观者清。我哪些地方做得不对，你就直言不讳吧！”曾国藩已感受到郭嵩焘的一片真心。 “第一，要联络好地方文武，不要总是站在与他们为敌的地位，当妥协处则妥协。常言说得好，强龙不压地头蛇。第二，越俎代庖之事不能再做，费力不讨好，反招怨敌。第三，要利用绿营的力量，不要再单枪匹马地干。若做到这三点，许多事情会办得好些。” 4.兵败后被高人指点, 从以前的“柔刚“ 开始 ”柔“ 曾国藩想起在长沙与绿营的龃龉斗法，与湖南官场的凿枘不合，想起在南昌与陈启迈、恽光宸的争强斗胜，这一切都是采取儒家直接、法家强权的方式。结果呢？表面上胜利了，实则埋下了更大的隐患。又如参清德、参陈启迈，越俎代庖、包揽干预种种情事，办理之时，固然痛快干脆，却没有想到锋芒毕露、刚烈太甚，伤害了清德、陈启迈的上上下下、左左右右，无形中给自己设置了许多障碍。这些隐患与障碍，如果不是自己亲身体验过，在书斋里、在六部签押房里是无论如何也设想不到的，它们对事业的损害，大大地超过了一时的风光和快意！既然直接的、以强对强的手法有时不能行得通，而迂回的、间接的、柔弱的方式也可以达到目的、战胜强者，且不至于留下隐患，为什么不采用呢？少年时代记住的诸如“大方无隅”“大音希声”“大象无形”“大巧若拙”的话，过去一直似懂非懂，现在一下子豁然开朗了。这些年来与官场内部以及与绿营的争斗，其实都是一种有隅之方，有声之音，有形之象，似巧实拙，真正的大方、大象、大巧不是这样的，它要做到全无形迹之嫌，全无斧凿之工。 “人之生也柔弱，其死也坚强，草木之生也柔脆，其死也枯槁。”柔弱、柔弱，天下万事万物，归根结底，莫不是以至柔克至刚。能克刚之柔，难道不是更刚吗？祖父“男儿以懦弱无刚为耻”的家训，自己竟片面理解了。曾国藩想到这里，兴奋地在《道德经》扉页上写下八个字：“大柔非柔，至刚无刚。”他觉得胸中的郁结解开了许多。 5.老友胡林翼更好的体现了”柔弱胜刚强“ 第二天一早，一顶花呢大轿将六姨太抬进巡抚衙门，胡太夫人、静娟夫人设盛宴款待，陪着玩牌听曲，扯家常。六姨太自幼丧母，见胡太夫人这样喜欢她，便认胡太夫人为母。胡太夫人高高兴兴地收下这个义女，又叫她拜见了兄长胡林翼。胡太夫人送给六姨太一副金镯金耳环金戒指，算是给义女的见面礼。六姨太回府后，在枕边对着官文说起胡家母子的千好万好。并说，从今以后两家认了亲，就是一家了，就不要再为难胡林翼了。官文对这个娇媚聪敏的六姨太向来百依百顺，果然从此再不给胡林翼找岔子了。军事民事，全付与胡林翼一手办理，他只在上面画诺而已；而胡林翼也表面上对他恭敬顺从。武昌城里督抚关系之亲密，为全国之首。 先前，曾国藩听到官胡这段故事后置之一笑。他笑胡林翼太软弱了，竟然用讨好一个姨太太的手腕来换取官文的合作，岂不太失堂堂大丈夫的气节！现在，他明白了，这正是胡林翼的高明之处，也是胡林翼胜过他的地方。“柔弱胜刚强”，胡林翼早已深懂此中之味，并运用得相当熟练了。</summary></entry><entry><title type="html">SpringBoot学习笔记</title><link href="http://localhost:4000/springBoot%E5%AD%A6%E4%B9%A0/" rel="alternate" type="text/html" title="SpringBoot学习笔记" /><published>2019-08-18T00:00:00+08:00</published><updated>2019-08-18T00:00:00+08:00</updated><id>http://localhost:4000/springBoot%E5%AD%A6%E4%B9%A0</id><content type="html" xml:base="http://localhost:4000/springBoot%E5%AD%A6%E4%B9%A0/">&lt;h3 id=&quot;记录学习springboot的过程&quot;&gt;记录学习SpringBoot的过程&lt;/h3&gt;

&lt;p&gt;Spring Boot是一个基于Java的开源框架，用于创建微服务&lt;/p&gt;

&lt;p&gt;SpringBoot的好处&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;避免在Spring中进行复杂的XML配置&lt;/li&gt;
  &lt;li&gt;以更简单的方式开发生产就绪的Spring应用程序&lt;/li&gt;
  &lt;li&gt;减少开发时间并独立运行应用程序&lt;/li&gt;
  &lt;li&gt;提供一种更简单的应用程序入门方式&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;正式开始springboot&quot;&gt;正式开始SpringBoot&lt;/h4&gt;

&lt;h5 id=&quot;1依赖springboot&quot;&gt;1.依赖SpringBoot&lt;/h5&gt;

&lt;p&gt;所有Spring Boot启动程序都遵循相同的命名模式&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring-boot-starter-*&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Spring Boot Starter Actuator依赖关系用于监视和管理应用程序。 其代码如下所示&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Spring Boot Starter Security依赖项用于Spring Security。 其代码如下所示&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Spring Boot Starter Web依赖项用于编写Rest端点。 其代码如下所示&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Spring Boot Starter Thyme Leaf依赖项用于创建Web应用程序。 其代码如下所示&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Spring Boot Starter Test依赖项用于编写测试用例。 其代码如下所示&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2-代码结构&quot;&gt;2. 代码结构&lt;/h5&gt;

&lt;p&gt;Java推荐的包声明命名约定是反向域名。 例如 - com.jack.projectName&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;com
    +- jack
        +- projectName
            +- Application.java
            |
            +- Model / Bean
            |    +- Model.java
            +- Dao
            |    +- Mapper.java
            +- Controller
            |    +- Controller.java
            +- Service
            |    +- Service.java
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;3-构建restful项目&quot;&gt;3. 构建Restful项目&lt;/h5&gt;

&lt;p&gt;@RestController注释用于定义RESTful Web服务。它提供JSON，XML和自定义响应。其语法如下所&lt;/p&gt;

&lt;p&gt;封装一个公共的返回对象，方便返回&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
public class CommonResult&amp;lt;T&amp;gt; {
    private long code;
    private String message;
    private T data;
    
    // 对接口的返回常用的类型做封装
    public static &amp;lt;T&amp;gt; CommonResult&amp;lt;T&amp;gt; success(T data) {
        return new CommonResult&amp;lt;T&amp;gt;(ResultCode.SUCCESS.getCode(), ResultCode.SUCCESS.getMessage(), data);
    }

    public static &amp;lt;T&amp;gt; CommonResult&amp;lt;T&amp;gt; success(T data, String message) {
        return new CommonResult&amp;lt;T&amp;gt;(ResultCode.SUCCESS.getCode(), message, data);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;SpringBoot的注解整理&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 读取环境或应用程序属性值
@Value(&quot;${property_key_name}&quot;)

// 定义RESTful Web服务。它提供JSON，XML和自定义响应
@RestController

// 注释用于定义访问REST端点的Request URI
@RequestMapping(value = &quot;/apiName&quot;)

// 注释用于定义请求正文内容类型
 public RequestResult userRegister(@RequestBody User user) {
    return RequestResult.success(&quot;注册成功&quot;);
    }
    
// 批注用于定义自定义或动态请求URI
@PathVariable
public ResponseEntity&amp;lt;Object&amp;gt; updateProduct(@PathVariable(&quot;id&quot;) String id) {

}

// 注释用于从请求URL读取请求参数
@RequestParam


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;开始编写接口&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RestController
public class UserController {


    @RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)
    @ResponseBody
    public CommonResult login(@RequestBody UmsAdminLoginParam umsAdminLoginParam, BindingResult result) {
        String token = adminService.login(umsAdminLoginParam.getUsername(), umsAdminLoginParam.getPassword());
        if (token == null) {
            return CommonResult.validateFailed(&quot;用户名或密码错误&quot;);
        }
        Map&amp;lt;String, String&amp;gt; tokenMap = new HashMap&amp;lt;&amp;gt;();
        tokenMap.put(&quot;token&quot;, token);
        tokenMap.put(&quot;tokenHead&quot;, tokenHead);
        return CommonResult.success(tokenMap);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Java" /><summary type="html">记录学习SpringBoot的过程 Spring Boot是一个基于Java的开源框架，用于创建微服务 SpringBoot的好处 避免在Spring中进行复杂的XML配置 以更简单的方式开发生产就绪的Spring应用程序 减少开发时间并独立运行应用程序 提供一种更简单的应用程序入门方式 正式开始SpringBoot 1.依赖SpringBoot 所有Spring Boot启动程序都遵循相同的命名模式spring-boot-starter-* Spring Boot Starter Actuator依赖关系用于监视和管理应用程序。 其代码如下所示 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Spring Boot Starter Security依赖项用于Spring Security。 其代码如下所示 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Spring Boot Starter Web依赖项用于编写Rest端点。 其代码如下所示 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Spring Boot Starter Thyme Leaf依赖项用于创建Web应用程序。 其代码如下所示 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Spring Boot Starter Test依赖项用于编写测试用例。 其代码如下所示 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 2. 代码结构 Java推荐的包声明命名约定是反向域名。 例如 - com.jack.projectName com +- jack +- projectName +- Application.java | +- Model / Bean | +- Model.java +- Dao | +- Mapper.java +- Controller | +- Controller.java +- Service | +- Service.java 3. 构建Restful项目 @RestController注释用于定义RESTful Web服务。它提供JSON，XML和自定义响应。其语法如下所 封装一个公共的返回对象，方便返回 public class CommonResult&amp;lt;T&amp;gt; { private long code; private String message; private T data; // 对接口的返回常用的类型做封装 public static &amp;lt;T&amp;gt; CommonResult&amp;lt;T&amp;gt; success(T data) { return new CommonResult&amp;lt;T&amp;gt;(ResultCode.SUCCESS.getCode(), ResultCode.SUCCESS.getMessage(), data); } public static &amp;lt;T&amp;gt; CommonResult&amp;lt;T&amp;gt; success(T data, String message) { return new CommonResult&amp;lt;T&amp;gt;(ResultCode.SUCCESS.getCode(), message, data); } } SpringBoot的注解整理 // 读取环境或应用程序属性值 @Value(&quot;${property_key_name}&quot;) // 定义RESTful Web服务。它提供JSON，XML和自定义响应 @RestController // 注释用于定义访问REST端点的Request URI @RequestMapping(value = &quot;/apiName&quot;) // 注释用于定义请求正文内容类型 public RequestResult userRegister(@RequestBody User user) { return RequestResult.success(&quot;注册成功&quot;); } // 批注用于定义自定义或动态请求URI @PathVariable public ResponseEntity&amp;lt;Object&amp;gt; updateProduct(@PathVariable(&quot;id&quot;) String id) { } // 注释用于从请求URL读取请求参数 @RequestParam 开始编写接口 @RestController public class UserController { @RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST) @ResponseBody public CommonResult login(@RequestBody UmsAdminLoginParam umsAdminLoginParam, BindingResult result) { String token = adminService.login(umsAdminLoginParam.getUsername(), umsAdminLoginParam.getPassword()); if (token == null) { return CommonResult.validateFailed(&quot;用户名或密码错误&quot;); } Map&amp;lt;String, String&amp;gt; tokenMap = new HashMap&amp;lt;&amp;gt;(); tokenMap.put(&quot;token&quot;, token); tokenMap.put(&quot;tokenHead&quot;, tokenHead); return CommonResult.success(tokenMap); } }</summary></entry><entry><title type="html">IM技术的整理</title><link href="http://localhost:4000/IM%E6%8A%80%E6%9C%AF%E7%9A%84%E6%95%B4%E7%90%86/" rel="alternate" type="text/html" title="IM技术的整理" /><published>2019-08-04T00:00:00+08:00</published><updated>2019-08-04T00:00:00+08:00</updated><id>http://localhost:4000/IM%E6%8A%80%E6%9C%AF%E7%9A%84%E6%95%B4%E7%90%86</id><content type="html" xml:base="http://localhost:4000/IM%E6%8A%80%E6%9C%AF%E7%9A%84%E6%95%B4%E7%90%86/">&lt;h2 id=&quot;通信协议&quot;&gt;通信协议&lt;/h2&gt;
&lt;p&gt;一套典型的IM通信协议设计分为三层：应用层、安全层、传输层&lt;/p&gt;

&lt;h3 id=&quot;im应用层协议&quot;&gt;IM应用层协议&lt;/h3&gt;
&lt;p&gt;应用层协议选型，常见的有三种：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;文本协议&lt;/li&gt;
  &lt;li&gt;二进制协议&lt;/li&gt;
  &lt;li&gt;流式XML协议&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;1-文本协议&quot;&gt;1. 文本协议&lt;/h4&gt;
&lt;p&gt;文本协议是指 “贴近人类书面语言表达”的通讯传输协议，典型的是http&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept: */*
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;文本协议的特点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可读性好，便于调试&lt;/li&gt;
  &lt;li&gt;解析效率一般（按照:分割，key value形式）&lt;/li&gt;
  &lt;li&gt;对二进制支持不好(图片 / 视频 / 语音)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-二进制协议&quot;&gt;2. 二进制协议&lt;/h4&gt;
&lt;p&gt;二进制协议一般定长包头和可扩展变长包体 ，每个字段固定了含义 
例: IP协议的前4个bit表示协议版本号（Version）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://docs.52im.net/extend/docs/book/tcpip/vol1/3/images2/52im_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;二进制协议特点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可读性差，难于调试&lt;/li&gt;
  &lt;li&gt;扩展性不好 ，如果要扩展字段，旧版协议就不兼容了，所以一般设计时会有一个Version字段&lt;/li&gt;
  &lt;li&gt;解析效率高(没有解析代价)&lt;/li&gt;
  &lt;li&gt;对二进制支持不好(图片 / 视频 / 语音)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-xml协议&quot;&gt;3. XML协议&lt;/h4&gt;
&lt;p&gt;XMPP使用XML协议，但XML使用太消耗流量&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;message
to=’[url=mailto:romeo@example.net]romeo@example.net[/url]’
from=’[url=mailto:juliet@example.com]juliet@example.com[/url]’
type=’chat’
xml : lang=’en’&amp;gt;
&amp;lt;body&amp;gt;Wherefore art thou, Romeo?&amp;lt;/body&amp;gt;
&amp;lt;/message&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;XML协议特点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a. 它是准标准协议，可以跨域互通&lt;/li&gt;
  &lt;li&gt;b. XML的优点，可读性好，扩展性好&lt;/li&gt;
  &lt;li&gt;c. 解析代价超高（dom解析）&lt;/li&gt;
  &lt;li&gt;d. 有效数据传输率超低（大量的标签）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4-实际使用协议&quot;&gt;4. 实际使用协议&lt;/h4&gt;
&lt;p&gt;一般常见的做法是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;定长二进制包头，可扩展变长包体。包体可以使用用文本、XML等扩展性好的协议。&lt;/li&gt;
  &lt;li&gt;包头负责传输和解析效率，与业务无关。包体保证扩展性，与业务相关。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//sizeof(cs_essay-header)=16
struct cs_essay-header{
    uint32_t version;
    uint32_t magic_num;
    uint32_t cmd;
    uint32_t len;
    uint8_t data[];
}__attribute__((packed));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;前4个字节是version&lt;/li&gt;
  &lt;li&gt;接下来的4个字节是个“魔法数字（magic_num）， 包头放几个约定好的特殊字符，包尾放几个约定好的特殊字符 约定好，发给你的协议，某几个字节位置，是0x 01020304 ，才是正常报文&lt;/li&gt;
  &lt;li&gt;接下来是command（命令号），用来区分是keepalive报文、业务报文、密钥交换报文等&lt;/li&gt;
  &lt;li&gt;len（包体长度），告知服务端要接收多长的包体&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Google开源的ProtoBuf协议具有更多有点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;现成的解析库种类多&lt;/li&gt;
  &lt;li&gt;现成的解析库种类多&lt;/li&gt;
  &lt;li&gt;在工业界已广泛应用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例： 登录请求包传入的是用户名与密码，登录响应包返回的是用户的uid&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message CUserLoginReq{
    optional string username = 1;
    optional string passwd = 2;
}

message CUserLoginResp{
    optional uint64 uid =1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;im安全层&quot;&gt;IM安全层&lt;/h3&gt;

&lt;p&gt;im协议，消息的保密性非常重要 ，谁都不希望自己聊天内容被看到，所以安全层是必不可少的&lt;/p&gt;

&lt;h5 id=&quot;ssl加密&quot;&gt;SSL加密&lt;/h5&gt;
&lt;p&gt;证书管理麻烦，代价比较高&lt;/p&gt;
&lt;h5 id=&quot;自定义加密策略&quot;&gt;自定义加密策略&lt;/h5&gt;
&lt;p&gt;自定义加密核心在于秘钥的生成，管理， 秘钥的管理大概有三种方式&lt;/p&gt;
&lt;h6 id=&quot;固定秘钥&quot;&gt;固定秘钥&lt;/h6&gt;
&lt;p&gt;服务端和客户端约定好一个密钥，同时约定好一个加密算法（eg：AES ），每次客户端im在发送前，就用约定好的算法，以及约定好的密钥加密再传输，服务端收到报文后，用约定好的算法，约定好的密钥再解密。这种方式，密钥和算法对程序员都是透明的。&lt;/p&gt;
&lt;h6 id=&quot;一人一秘钥&quot;&gt;一人一秘钥&lt;/h6&gt;
&lt;p&gt;简单说来就是每个人的密钥是固定的，但是每个人之间又不同，其实就是在固定密钥的算法中包含用户的某一特殊属性，比如用户uid、手机号、qq号等。&lt;/p&gt;
&lt;h6 id=&quot;动态秘钥&quot;&gt;动态秘钥&lt;/h6&gt;
&lt;p&gt;动态密钥，一Session一密钥的安全性更高，每次会话前协商密钥。密钥协商的过程要经过2次非对称密钥的随机生成，1次对称加密密钥的随机生成&lt;/p&gt;

&lt;h3 id=&quot;im传输层&quot;&gt;IM传输层&lt;/h3&gt;
&lt;p&gt;TCP / UDP&lt;/p&gt;

&lt;p&gt;一般大厂的做法的TCP和UDP混合使用&lt;/p&gt;

&lt;p&gt;“无线环境下，UDP更好，可以做到状态无关，而TCP不稳定，进出电梯就要断线，用户体验不好”&lt;/p&gt;</content><author><name></name></author><category term="架构" /><summary type="html">通信协议 一套典型的IM通信协议设计分为三层：应用层、安全层、传输层 IM应用层协议 应用层协议选型，常见的有三种： 文本协议 二进制协议 流式XML协议 1. 文本协议 文本协议是指 “贴近人类书面语言表达”的通讯传输协议，典型的是http Accept: */* User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36 文本协议的特点 可读性好，便于调试 解析效率一般（按照:分割，key value形式） 对二进制支持不好(图片 / 视频 / 语音) 2. 二进制协议 二进制协议一般定长包头和可扩展变长包体 ，每个字段固定了含义 例: IP协议的前4个bit表示协议版本号（Version） 二进制协议特点 可读性差，难于调试 扩展性不好 ，如果要扩展字段，旧版协议就不兼容了，所以一般设计时会有一个Version字段 解析效率高(没有解析代价) 对二进制支持不好(图片 / 视频 / 语音) 3. XML协议 XMPP使用XML协议，但XML使用太消耗流量 &amp;lt;message to=’[url=mailto:romeo@example.net]romeo@example.net[/url]’ from=’[url=mailto:juliet@example.com]juliet@example.com[/url]’ type=’chat’ xml : lang=’en’&amp;gt; &amp;lt;body&amp;gt;Wherefore art thou, Romeo?&amp;lt;/body&amp;gt; &amp;lt;/message&amp;gt; XML协议特点 a. 它是准标准协议，可以跨域互通 b. XML的优点，可读性好，扩展性好 c. 解析代价超高（dom解析） d. 有效数据传输率超低（大量的标签） 4. 实际使用协议 一般常见的做法是： 定长二进制包头，可扩展变长包体。包体可以使用用文本、XML等扩展性好的协议。 包头负责传输和解析效率，与业务无关。包体保证扩展性，与业务相关。 //sizeof(cs_essay-header)=16 struct cs_essay-header{ uint32_t version; uint32_t magic_num; uint32_t cmd; uint32_t len; uint8_t data[]; }__attribute__((packed)); 前4个字节是version 接下来的4个字节是个“魔法数字（magic_num）， 包头放几个约定好的特殊字符，包尾放几个约定好的特殊字符 约定好，发给你的协议，某几个字节位置，是0x 01020304 ，才是正常报文 接下来是command（命令号），用来区分是keepalive报文、业务报文、密钥交换报文等 len（包体长度），告知服务端要接收多长的包体 Google开源的ProtoBuf协议具有更多有点 现成的解析库种类多 现成的解析库种类多 在工业界已广泛应用 例： 登录请求包传入的是用户名与密码，登录响应包返回的是用户的uid message CUserLoginReq{ optional string username = 1; optional string passwd = 2; } message CUserLoginResp{ optional uint64 uid =1; } IM安全层 im协议，消息的保密性非常重要 ，谁都不希望自己聊天内容被看到，所以安全层是必不可少的 SSL加密 证书管理麻烦，代价比较高 自定义加密策略 自定义加密核心在于秘钥的生成，管理， 秘钥的管理大概有三种方式 固定秘钥 服务端和客户端约定好一个密钥，同时约定好一个加密算法（eg：AES ），每次客户端im在发送前，就用约定好的算法，以及约定好的密钥加密再传输，服务端收到报文后，用约定好的算法，约定好的密钥再解密。这种方式，密钥和算法对程序员都是透明的。 一人一秘钥 简单说来就是每个人的密钥是固定的，但是每个人之间又不同，其实就是在固定密钥的算法中包含用户的某一特殊属性，比如用户uid、手机号、qq号等。 动态秘钥 动态密钥，一Session一密钥的安全性更高，每次会话前协商密钥。密钥协商的过程要经过2次非对称密钥的随机生成，1次对称加密密钥的随机生成 IM传输层 TCP / UDP 一般大厂的做法的TCP和UDP混合使用 “无线环境下，UDP更好，可以做到状态无关，而TCP不稳定，进出电梯就要断线，用户体验不好”</summary></entry></feed>